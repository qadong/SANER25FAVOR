[
    {
        "index": 186496,
        "output": "<Vul_Start> case GL_PROGRAM_COMPLETION_QUERY_CHROMIUM:<Vul_End>",
        "label": "<Vul_Start> case GL_PROGRAM_COMPLETION_QUERY_CHROMIUM:<Vul_End>",
        "match": true,
        "source": " void GLES2Implementation::BeginQueryEXT(GLenum target, GLuint id) { GPU_CLIENT_SINGLE_THREAD_CHECK(); GPU_CLIENT_LOG(\"[\" << GetLogPrefix() << \"] BeginQueryEXT(\" << GLES2Util::GetStringQueryTarget(target) << \", \" << id << \")\"); switch (target) { case GL_COMMANDS_ISSUED_CHROMIUM: case GL_LATENCY_QUERY_CHROMIUM: case GL_ASYNC_PIXEL_PACK_COMPLETED_CHROMIUM: case GL_GET_ERROR_QUERY_CHROMIUM: <Vul_Start><Vul_End> break; case GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM: case GL_COMMANDS_COMPLETED_CHROMIUM: if (!capabilities_.sync_query) { SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"not enabled for commands completed queries\"); return; } break; case GL_SAMPLES_PASSED_ARB: if (!capabilities_.occlusion_query) { SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"not enabled for occlusion queries\"); return; } break; case GL_ANY_SAMPLES_PASSED: case GL_ANY_SAMPLES_PASSED_CONSERVATIVE: if (!capabilities_.occlusion_query_boolean) { SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"not enabled for boolean occlusion queries\"); return; } break; case GL_TIME_ELAPSED_EXT: if (!capabilities_.timer_queries) { SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"not enabled for timing queries\"); return; } break; case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: if (capabilities_.major_version >= 3) break; FALLTHROUGH; default: SetGLError(GL_INVALID_ENUM, \"glBeginQueryEXT\", \"unknown query target\"); return; } if (query_tracker_->GetCurrentQuery(target)) { SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"query already in progress\"); return; } if (id == 0) { SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"id is 0\"); return; } if (!GetIdAllocator(IdNamespaces::kQueries)->InUse(id)) { SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"invalid id\"); return; } switch (target) { case GL_TIME_ELAPSED_EXT: if (!query_tracker_->SetDisjointSync(this)) { SetGLError(GL_OUT_OF_MEMORY, \"glBeginQueryEXT\", \"buffer allocation failed\"); return; } break; default: break; } if (query_tracker_->BeginQuery(id, target, this)) CheckGLError(); if (target == GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM) { AllocateShadowCopiesForReadback(); } } ",
        "vulrepair": "<Vul_Start> case GL_PROGRAM_COMPLETION_QUERY_CHROMIUM: case GL_PROGRAM_COMPLETION_QUERY_CHROMIUM: case GL_PROGRAM_COMPLETION_QUERY_CHROMIUM: case GL_PROGRAM_COMPLETION_QUERY_CHROMIUM: case GL_PROGRAM_COMPLETION_QUERY_CHROMIUM: case GL_PROGRAM_COMPLETION_QUERY_CHROMIUM: case GL_PROGRAM_COMPLETION_QUERY_CHROMIUM:<Vul_End>"
    },
    {
        "index": 188606,
        "output": "<Vul_Start> vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();<Vul_End>",
        "label": "<Vul_Start> vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();<Vul_End>",
        "match": true,
        "source": " TileIndependenceTest() : EncoderTest(GET_PARAM(0)), md5_fw_order_(), md5_inv_order_(), n_tiles_(GET_PARAM(1)) { init_flags_ = VPX_CODEC_USE_PSNR; <Vul_Start> vpx_codec_dec_cfg_t cfg; <Vul_End> cfg.w = 704; cfg.h = 144; cfg.threads = 1; fw_dec_ = codec_->CreateDecoder(cfg, 0); inv_dec_ = codec_->CreateDecoder(cfg, 0); inv_dec_->Control(VP9_INVERT_TILE_DECODE_ORDER, 1); } ",
        "vulrepair": "<Vul_Start> vpx_codec_dec_cfg_t cfg = {};<Vul_End>"
    },
    {
        "index": 181485,
        "output": "<Vul_Start> ushort huff[1024], vpred[2][2], hpred[2];<Vul_End>",
        "label": "<Vul_Start> ushort huff[1024], vpred[2][2], hpred[2];<Vul_End>",
        "match": true,
        "source": " void CLASS foveon_dp_load_raw() { unsigned c, roff[4], row, col, diff; <Vul_Start> ushort huff[512], vpred[2][2], hpred[2]; <Vul_End> fseek (ifp, 8, SEEK_CUR); foveon_huff (huff); roff[0] = 48; FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16); FORC3 { fseek (ifp, data_offset+roff[c], SEEK_SET); getbits(-1); vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512; for (row=0; row < height; row++) { #ifdef LIBRAW_LIBRARY_BUILD checkCancel(); #endif for (col=0; col < width; col++) { diff = ljpeg_diff(huff); if (col < 2) hpred[col] = vpred[row & 1][col] += diff; else hpred[col & 1] += diff; image[row*width+col][c] = hpred[col & 1]; } } } } ",
        "vulrepair": "<Vul_Start> ushort huff[512], vpred[2][2], hpred[2];<Vul_End>"
    },
    {
        "index": 184514,
        "output": "<Vul_Start> DCHECK_EQ(client, invalidation_client_.get());<Vul_End>",
        "label": "<Vul_Start> DCHECK_EQ(client, invalidation_client_.get());<Vul_End>",
        "match": true,
        "source": " void ChromeInvalidationClient::InvalidateUnknownVersion( invalidation::InvalidationClient* client, const invalidation::ObjectId& object_id, const invalidation::AckHandle& ack_handle) { DCHECK(CalledOnValidThread()); <Vul_Start><Vul_End> DVLOG(1) << \"InvalidateUnknownVersion\"; ObjectIdPayloadMap id_payloads; id_payloads[object_id] = std::string(); EmitInvalidation(id_payloads); client->Acknowledge(ack_handle); } ",
        "vulrepair": "<Vul_Start> DCHECK_EQ(client, invalidation_client::Get());<Vul_End>"
    },
    {
        "index": 185872,
        "output": "<Vul_Start> DVLOG(1) << __FUNCTION__;<Vul_End>",
        "label": "<Vul_Start> DVLOG(1) << __FUNCTION__;<Vul_End>",
        "match": true,
        "source": " void VRDisplay::OnBlur() { <Vul_Start><Vul_End> display_blurred_ = true; vr_v_sync_provider_.reset(); navigator_vr_->EnqueueVREvent(VRDisplayEvent::Create( EventTypeNames::vrdisplayblur, true, false, this, \"\")); } ",
        "vulrepair": "<Vul_Start> DVLOG(2) << __FUNCTION__;<Vul_End>"
    },
    {
        "index": 182298,
        "output": "<Vul_Start> len = mutt_b64_decode(obuf, idata->buf + 2, sizeof(obuf));<Vul_End>",
        "label": "<Vul_Start> len = mutt_b64_decode(obuf, idata->buf + 2, sizeof(obuf));<Vul_End>",
        "match": true,
        "source": " enum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method) { char ibuf[LONG_STRING * 2], obuf[LONG_STRING]; unsigned char hmac_response[MD5_DIGEST_LEN]; int len; int rc; if (!mutt_bit_isset(idata->capabilities, ACRAM_MD5)) return IMAP_AUTH_UNAVAIL; mutt_message(_(\"Authenticating (CRAM-MD5)...\")); if (mutt_account_getlogin(&idata->conn->account) < 0) return IMAP_AUTH_FAILURE; if (mutt_account_getpass(&idata->conn->account) < 0) return IMAP_AUTH_FAILURE; imap_cmd_start(idata, \"AUTHENTICATE CRAM-MD5\"); do rc = imap_cmd_step(idata); while (rc == IMAP_CMD_CONTINUE); if (rc != IMAP_CMD_RESPOND) { mutt_debug(1, \"Invalid response from server: %s\\n\", ibuf); goto bail; } <Vul_Start> len = mutt_b64_decode(obuf, idata->buf + 2); <Vul_End> if (len == -1) { mutt_debug(1, \"Error decoding base64 response.\\n\"); goto bail; } obuf[len] = '\\0'; mutt_debug(2, \"CRAM challenge: %s\\n\", obuf); hmac_md5(idata->conn->account.pass, obuf, hmac_response); int off = snprintf(obuf, sizeof(obuf), \"%s \", idata->conn->account.user); mutt_md5_toascii(hmac_response, obuf + off); mutt_debug(2, \"CRAM response: %s\\n\", obuf); mutt_b64_encode(ibuf, obuf, strlen(obuf), sizeof(ibuf) - 2); mutt_str_strcat(ibuf, sizeof(ibuf), \"\\r\\n\"); mutt_socket_send(idata->conn, ibuf); do rc = imap_cmd_step(idata); while (rc == IMAP_CMD_CONTINUE); if (rc != IMAP_CMD_OK) { mutt_debug(1, \"Error receiving server response.\\n\"); goto bail; } if (imap_code(idata->buf)) return IMAP_AUTH_SUCCESS; bail: mutt_error(_(\"CRAM-MD5 authentication failed.\")); return IMAP_AUTH_FAILURE; } ",
        "vulrepair": "<Vul_Start> len = mutt_b64_decode(idata->buf + 2, sizeof(obuf), idata->buf + 2 + sizeof(obuf) - 2);<Vul_End>"
    },
    {
        "index": 181788,
        "output": "<Vul_Start> status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); }<Vul_End>",
        "label": "<Vul_Start> status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); }<Vul_End>",
        "match": true,
        "source": " static Image *ReadVICARImage(const ImageInfo *image_info, ExceptionInfo *exception) { char keyword[MaxTextExtent], value[MaxTextExtent]; Image *image; int c; MagickBooleanType status, value_expected; QuantumInfo *quantum_info; QuantumType quantum_type; register PixelPacket *q; size_t length; ssize_t count, y; unsigned char *pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } c=ReadBlobByte(image); count=1; if (c == EOF) { image=DestroyImage(image); return((Image *) NULL); } length=0; image->columns=0; image->rows=0; while (isgraph(c) && ((image->columns == 0) || (image->rows == 0))) { if (isalnum(c) == MagickFalse) { c=ReadBlobByte(image); count++; } else { register char *p; p=keyword; do { if ((size_t) (p-keyword) < (MaxTextExtent-1)) *p++=c; c=ReadBlobByte(image); count++; } while (isalnum(c) || (c == '_')); *p='\\0'; value_expected=MagickFalse; while ((isspace((int) ((unsigned char) c)) != 0) || (c == '=')) { if (c == '=') value_expected=MagickTrue; c=ReadBlobByte(image); count++; } if (value_expected == MagickFalse) continue; p=value; while (isalnum(c)) { if ((size_t) (p-value) < (MaxTextExtent-1)) *p++=c; c=ReadBlobByte(image); count++; } *p='\\0'; if (LocaleCompare(keyword,\"Label_RECORDS\") == 0) length=(ssize_t) StringToLong(value); if (LocaleCompare(keyword,\"LBLSIZE\") == 0) length=(ssize_t) StringToLong(value); if (LocaleCompare(keyword,\"RECORD_BYTES\") == 0) image->columns=StringToUnsignedLong(value); if (LocaleCompare(keyword,\"NS\") == 0) image->columns=StringToUnsignedLong(value); if (LocaleCompare(keyword,\"LINES\") == 0) image->rows=StringToUnsignedLong(value); if (LocaleCompare(keyword,\"NL\") == 0) image->rows=StringToUnsignedLong(value); } while (isspace((int) ((unsigned char) c)) != 0) { c=ReadBlobByte(image); count++; } } while (count < (ssize_t) length) { c=ReadBlobByte(image); count++; } if ((image->columns == 0) || (image->rows == 0)) ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\"); image->depth=8; if (image_info->ping != MagickFalse) { (void) CloseBlob(image); return(GetFirstImageInList(image)); } <Vul_Start><Vul_End> (void) SetImageColorspace(image,GRAYColorspace); quantum_type=GrayQuantum; quantum_info=AcquireQuantumInfo(image_info,image); if (quantum_info == (QuantumInfo *) NULL) ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"); pixels=GetQuantumPixels(quantum_info); length=GetQuantumExtent(image,quantum_info,quantum_type); for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (PixelPacket *) NULL) break; count=ReadBlob(image,length,pixels); (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info, quantum_type,pixels,exception); if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } SetQuantumImageType(image,quantum_type); quantum_info=DestroyQuantumInfo(quantum_info); if (EOFBlob(image) != MagickFalse) ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\", image->filename); (void) CloseBlob(image); return(GetFirstImageInList(image)); } ",
        "vulrepair": "<Vul_Start> if ((image->columns == 0) || (image->rows == 0))<Vul_End><Vul_Start> if ((image->columns == 0) && (image->rows == 0))<Vul_End><Vul_Start> if ((image->columns == 0) && (image->rows == 0))<Vul_End><Vul_Start> if ((image->columns == 0) && (image->rows == 0))<Vul_End><Vul_Start> if ((image->columns == 0) && (image->rows == 0))<Vul_End><Vul_Start> (image->columns == 0) || (image->rows == 0))<Vul_End><Vul_Start> if ((image->columns == 0) && (image->rows == 0))<Vul_End><Vul_Start> (image->columns == 0) && (image->rows == 0))<Vul_End><Vul_Start> (image->columns == 0) && (image->rows == 0))<Vul_End><Vul_Start> (image->columns == 0) && (image->rows == 0))<Vul_End><Vul_Start> (image->columns == 0))<Vul_End><Vul_Start> (image->rows == 0))<Vul_End><Vul_Start> (image->rows == 0))<Vul_End><Vul_Start> (void) DecodePixelPacket(pixels,"
    },
    {
        "index": 185989,
        "output": "<Vul_Start> if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {<Vul_End>",
        "label": "<Vul_Start> if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {<Vul_End>",
        "match": true,
        "source": " bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* attributeName, v8::Local<v8::Value> holder, v8::Local<v8::Value> v8Value) { v8::Isolate* isolate = scriptState->isolate(); v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className); v8::Local<v8::Value> descriptor; if (!classObject->GetOwnPropertyDescriptor(scriptState->context(), v8String(isolate, attributeName)).ToLocal(&descriptor) || !descriptor->IsObject()) { fprintf(stderr, \"Private script error: Target DOM attribute setter was not found. (Class name = %s, Attribute name = %s)\\n\", className, attributeName); RELEASE_NOTREACHED(); } v8::Local<v8::Value> setter; if (!v8::Local<v8::Object>::Cast(descriptor)->Get(scriptState->context(), v8String(isolate, \"set\")).ToLocal(&setter) || !setter->IsFunction()) { fprintf(stderr, \"Private script error: Target DOM attribute setter was not found. (Class name = %s, Attribute name = %s)\\n\", className, attributeName); RELEASE_NOTREACHED(); } initializeHolderIfNeeded(scriptState, classObject, holder); v8::Local<v8::Value> argv[] = { v8Value }; v8::TryCatch block(isolate); v8::Local<v8::Value> result; <Vul_Start> if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) { <Vul_End> rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className); block.ReThrow(); return false; } return true; } ",
        "vulrepair": "<Vul_Start> if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), isolate).ToLocal(&result)) {<Vul_End>"
    },
    {
        "index": 180869,
        "output": "<Vul_Start> mark_key_instantiated(key, 0);<Vul_End>",
        "label": "<Vul_Start> mark_key_instantiated(key, 0);<Vul_End>",
        "match": true,
        "source": " static inline key_ref_t __key_update(key_ref_t key_ref, struct key_preparsed_payload *prep) { struct key *key = key_ref_to_ptr(key_ref); int ret; ret = key_permission(key_ref, KEY_NEED_WRITE); if (ret < 0) goto error; ret = -EEXIST; if (!key->type->update) goto error; down_write(&key->sem); ret = key->type->update(key, prep); if (ret == 0) <Vul_Start> clear_bit(KEY_FLAG_NEGATIVE, &key->flags); <Vul_End> up_write(&key->sem); if (ret < 0) goto error; out: return key_ref; error: key_put(key); key_ref = ERR_PTR(ret); goto out; } ",
        "vulrepair": "<Vul_Start> mark_key_instantiated(key);<Vul_End>"
    },
    {
        "index": 177963,
        "output": "<Vul_Start> if (!pkey) { ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER); return -1; } <Vul_End>",
        "label": "<Vul_Start> if (!pkey) { ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER); return -1; } <Vul_End>",
        "match": true,
        "source": " int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey) { EVP_MD_CTX ctx; unsigned char *buf_in=NULL; int ret= -1,inl; int mdnid, pknid; <Vul_Start><Vul_End> EVP_MD_CTX_init(&ctx); { if (!pkey->ameth || !pkey->ameth->item_verify) { ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM); goto err; } ret = pkey->ameth->item_verify(&ctx, it, asn, a, signature, pkey); if (ret != 2) goto err; ret = -1; } else { const EVP_MD *type; type=EVP_get_digestbynid(mdnid); if (type == NULL) { ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM); goto err; } if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id) { ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE); goto err; } if (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey)) { ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB); ret=0; goto err; } } inl = ASN1_item_i2d(asn, &buf_in, it); if (buf_in == NULL) { ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE); goto err; } if (!EVP_DigestVerifyUpdate(&ctx,buf_in,inl)) { ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB); ret=0; goto err; } OPENSSL_cleanse(buf_in,(unsigned int)inl); OPENSSL_free(buf_in); if (EVP_DigestVerifyFinal(&ctx,signature->data, (size_t)signature->length) <= 0) { ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB); ret=0; goto err; } ret=1; err: EVP_MD_CTX_cleanup(&ctx); return(ret); } ",
        "vulrepair": "<Vul_Start> if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7) { ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT); return -1; } <Vul_End>"
    },
    {
        "index": 187528,
        "output": "<Vul_Start> if (venc_handle->is_secure_session()) { DEBUG_PRINT_ERROR(\"logging secure input buffers is not allowed!\"); return -1; } <Vul_End>",
        "label": "<Vul_Start> if (venc_handle->is_secure_session()) { DEBUG_PRINT_ERROR(\"logging secure input buffers is not allowed!\"); return -1; } <Vul_End>",
        "match": true,
        "source": " int venc_dev::venc_input_log_buffers(OMX_BUFFERHEADERTYPE *pbuffer, int fd, int plane_offset) { <Vul_Start><Vul_End> if (!m_debug.infile) { int size = snprintf(m_debug.infile_name, PROPERTY_VALUE_MAX, \"%s/input_enc_%lu_%lu_%p.yuv\", m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this); if ((size > PROPERTY_VALUE_MAX) && (size < 0)) { DEBUG_PRINT_ERROR(\"Failed to open output file: %s for logging size:%d\", m_debug.infile_name, size); } m_debug.infile = fopen (m_debug.infile_name, \"ab\"); if (!m_debug.infile) { DEBUG_PRINT_HIGH(\"Failed to open input file: %s for logging\", m_debug.infile_name); m_debug.infile_name[0] = '\\0'; return -1; } } if (m_debug.infile && pbuffer && pbuffer->nFilledLen) { unsigned long i, msize; int stride = VENUS_Y_STRIDE(COLOR_FMT_NV12, m_sVenc_cfg.input_width); int scanlines = VENUS_Y_SCANLINES(COLOR_FMT_NV12, m_sVenc_cfg.input_height); unsigned char *pvirt,*ptemp; char *temp = (char *)pbuffer->pBuffer; msize = VENUS_BUFFER_SIZE(COLOR_FMT_NV12, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height); if (metadatamode == 1) { pvirt= (unsigned char *)mmap(NULL, msize, PROT_READ|PROT_WRITE,MAP_SHARED, fd, plane_offset); if (pvirt) { ptemp = pvirt; for (i = 0; i < m_sVenc_cfg.input_height; i++) { fwrite(ptemp, m_sVenc_cfg.input_width, 1, m_debug.infile); ptemp += stride; } ptemp = pvirt + (stride * scanlines); for(i = 0; i < m_sVenc_cfg.input_height/2; i++) { fwrite(ptemp, m_sVenc_cfg.input_width, 1, m_debug.infile); ptemp += stride; } munmap(pvirt, msize); } else if (pvirt == MAP_FAILED) { DEBUG_PRINT_ERROR(\"%s mmap failed\", __func__); return -1; } } else { for (i = 0; i < m_sVenc_cfg.input_height; i++) { fwrite(temp, m_sVenc_cfg.input_width, 1, m_debug.infile); temp += stride; } temp = (char *)pbuffer->pBuffer + (stride * scanlines); for(i = 0; i < m_sVenc_cfg.input_height/2; i++) { fwrite(temp, m_sVenc_cfg.input_width, 1, m_debug.infile); temp += stride; } } } return 0; } ",
        "vulrepair": "<Vul_Start> if (venc_handle->m_venc_is_secure_session()) { DEBUG_PRINT_ERROR(\"logging secure input buffers is not allowed!\"); return -1; } <Vul_End>"
    },
    {
        "index": 183587,
        "output": "<Vul_Start> MessageLoop::current()->PostDelayedTask( FROM_HERE, NewRunnableMethod( this, &PluginInstance::OnTimerCall, func, npp_, timer_id), info.interval);<Vul_End><Vul_Start><Vul_End>",
        "label": "<Vul_Start> MessageLoop::current()->PostDelayedTask( FROM_HERE, NewRunnableMethod( this, &PluginInstance::OnTimerCall, func, npp_, timer_id), info.interval);<Vul_End><Vul_Start><Vul_End>",
        "match": true,
        "source": " void PluginInstance::OnTimerCall(void (*func)(NPP id, uint32 timer_id), NPP id, uint32 timer_id) { TimerMap::iterator it = timers_.find(timer_id); if (it == timers_.end()) return; TimerInfo info = it->second; func(id, timer_id); if (timers_.find(timer_id) == timers_.end()) return; if (info.repeat) { <Vul_Start><Vul_End> <Vul_Start> message_loop_->PostDelayedTask(FROM_HERE, NewRunnableMethod( this, &PluginInstance::OnTimerCall, func, npp_, timer_id), info.interval); <Vul_End> } else { timers_.erase(it); } } ",
        "vulrepair": "<Vul_Start> if (info.interval > 0) {<Vul_End><Vul_Start> message_loop_->PostDelayedTask( FROM_HERE, NewRunnableMethod( this, &PluginInstance::OnTimerCall, func, npp_, timer_id), info.interval); }<Vul_End>"
    },
    {
        "index": 186284,
        "output": "<Vul_Start> if (IsFullscreenForCurrentTab()) ExitFullscreen(true); <Vul_End>",
        "label": "<Vul_Start> if (IsFullscreenForCurrentTab()) ExitFullscreen(true); <Vul_End>",
        "match": true,
        "source": " void WebContentsImpl::RunJavaScriptDialog(RenderFrameHost* render_frame_host, const base::string16& message, const base::string16& default_prompt, const GURL& frame_url, JavaScriptDialogType dialog_type, IPC::Message* reply_msg) { <Vul_Start><Vul_End> bool suppress_this_message = ShowingInterstitialPage() || !delegate_ || delegate_->ShouldSuppressDialogs(this) || !delegate_->GetJavaScriptDialogManager(this); if (!suppress_this_message) { is_showing_javascript_dialog_ = true; dialog_manager_ = delegate_->GetJavaScriptDialogManager(this); dialog_manager_->RunJavaScriptDialog( this, frame_url, dialog_type, message, default_prompt, base::Bind(&WebContentsImpl::OnDialogClosed, base::Unretained(this), render_frame_host->GetProcess()->GetID(), render_frame_host->GetRoutingID(), reply_msg, false), &suppress_this_message); } if (suppress_this_message) { OnDialogClosed(render_frame_host->GetProcess()->GetID(), render_frame_host->GetRoutingID(), reply_msg, true, false, base::string16()); } } ",
        "vulrepair": "<Vul_Start> if (is_showing_javascript_dialog_) return; <Vul_End>"
    },
    {
        "index": 180341,
        "output": "<Vul_Start> <Vul_End>",
        "label": "<Vul_Start> <Vul_End>",
        "match": true,
        "source": " static enum entity_charset determine_charset(char *charset_hint TSRMLS_DC) { int i; enum entity_charset charset = cs_utf_8; int len = 0; const zend_encoding *zenc; if (charset_hint == NULL) return cs_utf_8; if ((len = strlen(charset_hint)) != 0) { goto det_charset; } zenc = zend_multibyte_get_internal_encoding(TSRMLS_C); if (zenc != NULL) { charset_hint = (char *)zend_multibyte_get_encoding_name(zenc); if (charset_hint != NULL && (len=strlen(charset_hint)) != 0) { if ((len == 4) && (!memcmp(\"pass\", charset_hint, 4) || !memcmp(\"auto\", charset_hint, 4) || !memcmp(\"auto\", charset_hint, 4))) { charset_hint = NULL; len = 0; } else { goto det_charset; } } } charset_hint = SG(default_charset); if (charset_hint != NULL && (len=strlen(charset_hint)) != 0) { goto det_charset; } #if HAVE_NL_LANGINFO && HAVE_LOCALE_H && defined(CODESET) charset_hint = nl_langinfo(CODESET); if (charset_hint != NULL && (len=strlen(charset_hint)) != 0) { goto det_charset; } #endif #if HAVE_LOCALE_H { char *localename; char *dot, *at; localename = setlocale(LC_CTYPE, NULL); dot = strchr(localename, '.'); if (dot) { dot++; at = strchr(dot, '@'); if (at) len = at - dot; else len = strlen(dot); charset_hint = dot; } else { charset_hint = localename; len = strlen(charset_hint); } } #endif det_charset: if (charset_hint) { int found = 0; <Vul_Start><Vul_End> for (i = 0; charset_map[i].codeset; i++) { if (len == strlen(charset_map[i].codeset) && strncasecmp(charset_hint, charset_map[i].codeset, len) == 0) { charset = charset_map[i].charset; found = 1; break; } } if (!found) { php_error_docref(NULL TSRMLS_CC, E_WARNING, \"charset `%s' not supported, assuming utf-8\", charset_hint); } } return charset; } ",
        "vulrepair": "<Vul_Start> if (len < 1) { charset_hint = NULL; len = 0; }<Vul_End>"
    },
    {
        "index": 182366,
        "output": "<Vul_Start><Vul_End><Vul_Start> if (err == MP_OKAY) { if (mp_iszero(k) == MP_YES) err = MP_ZERO_E; }<Vul_End>",
        "label": "<Vul_Start><Vul_End><Vul_Start> if (err == MP_OKAY) { if (mp_iszero(k) == MP_YES) err = MP_ZERO_E; } <Vul_End>",
        "match": true,
        "source": " static int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order) { int err; #ifdef WOLFSSL_SMALL_STACK byte* buf; #else byte buf[ECC_MAXSIZE_GEN]; #endif #ifdef WOLFSSL_SMALL_STACK buf = (byte*)XMALLOC(ECC_MAXSIZE_GEN, NULL, DYNAMIC_TYPE_ECC_BUFFER); if (buf == NULL) return MEMORY_E; #endif size += 8; err = wc_RNG_GenerateBlock(rng, buf, size); if (err == 0) err = mp_read_unsigned_bin(k, (byte*)buf, size); <Vul_Start> if (err == MP_OKAY) { if (mp_iszero(k) == MP_YES) err = MP_ZERO_E; } <Vul_End> if (err == MP_OKAY) { if (mp_cmp(k, order) != MP_LT) { err = mp_mod(k, order, k); } } <Vul_Start><Vul_End> ForceZero(buf, ECC_MAXSIZE); #ifdef WOLFSSL_SMALL_STACK XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER); #endif return err; } ",
        "vulrepair": "<Vul_Start> if (mp_iszero(k) == MP_YES) err = MP_ZERO_E;<Vul_End><Vul_Start> if (mp_cmp(k, order)!= MP_LT) { err = MP_ZERO_E; }<Vul_End>"
    },
    {
        "index": 181758,
        "output": "<Vul_Start> MagickBooleanType status;<Vul_End><Vul_Start> status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); }<Vul_End>",
        "label": "<Vul_Start> MagickBooleanType status; <Vul_End><Vul_Start> status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); }<Vul_End>",
        "match": true,
        "source": " static Image *ReadNULLImage(const ImageInfo *image_info, ExceptionInfo *exception) { Image *image; <Vul_Start><Vul_End> MagickPixelPacket background; register IndexPacket *indexes; register ssize_t x; register PixelPacket *q; ssize_t y; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); if (image->columns == 0) image->columns=1; if (image->rows == 0) image->rows=1; <Vul_Start><Vul_End> image->matte=MagickTrue; GetMagickPixelPacket(image,&background); background.opacity=(MagickRealType) TransparentOpacity; if (image->colorspace == CMYKColorspace) ConvertRGBToCMYK(&background); for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (PixelPacket *) NULL) break; indexes=GetAuthenticIndexQueue(image); for (x=0; x < (ssize_t) image->columns; x++) { SetPixelPacket(image,&background,q,indexes); q++; indexes++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; } return(GetFirstImageInList(image)); } ",
        "vulrepair": "<Vul_Start> image=AcquireImage(image_info); if (image == (Image *) NULL) return(DestroyImage(image));<Vul_End><Vul_Start> image->columns=1; image->rows=1;<Vul_End>"
    },
    {
        "index": 181740,
        "output": "<Vul_Start> status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); }<Vul_End>",
        "label": "<Vul_Start> status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); }<Vul_End>",
        "match": true,
        "source": " static Image *ReadGRAYImage(const ImageInfo *image_info, ExceptionInfo *exception) { Image *canvas_image, *image; MagickBooleanType status; MagickOffsetType scene; QuantumInfo *quantum_info; QuantumType quantum_type; size_t length; ssize_t count, y; unsigned char *pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); if ((image->columns == 0) || (image->rows == 0)) ThrowReaderException(OptionError,\"MustSpecifyImageSize\"); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } if (DiscardBlobBytes(image,(size_t) image->offset) == MagickFalse) ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\", image->filename); SetImageColorspace(image,GRAYColorspace); canvas_image=CloneImage(image,image->extract_info.width,1,MagickFalse, exception); (void) SetImageVirtualPixelMethod(canvas_image,BlackVirtualPixelMethod); quantum_type=GrayQuantum; quantum_info=AcquireQuantumInfo(image_info,canvas_image); if (quantum_info == (QuantumInfo *) NULL) ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"); pixels=GetQuantumPixels(quantum_info); if (image_info->number_scenes != 0) while (image->scene < image_info->scene) { image->scene++; length=GetQuantumExtent(canvas_image,quantum_info,quantum_type); for (y=0; y < (ssize_t) image->rows; y++) { count=ReadBlob(image,length,pixels); if (count != (ssize_t) length) break; } } scene=0; count=0; length=0; do { if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0)) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; <Vul_Start><Vul_End> SetImageColorspace(image,GRAYColorspace); if (scene == 0) { length=GetQuantumExtent(canvas_image,quantum_info,quantum_type); count=ReadBlob(image,length,pixels); } for (y=0; y < (ssize_t) image->extract_info.height; y++) { register const PixelPacket *restrict p; register ssize_t x; register PixelPacket *restrict q; if (count != (ssize_t) length) { ThrowFileException(exception,CorruptImageError, \"UnexpectedEndOfFile\",image->filename); break; } q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,exception); if (q == (PixelPacket *) NULL) break; length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,quantum_info, quantum_type,pixels,exception); if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse) break; if (((y-image->extract_info.y) >= 0) && ((y-image->extract_info.y) < (ssize_t) image->rows)) { p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0, image->columns,1,exception); q=QueueAuthenticPixels(image,0,y-image->extract_info.y,image->columns, 1,exception); if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelRed(q,GetPixelRed(p)); SetPixelGreen(q,GetPixelGreen(p)); SetPixelBlue(q,GetPixelBlue(p)); p++; q++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; } if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } count=ReadBlob(image,length,pixels); } SetQuantumImageType(image,quantum_type); if (image_info->number_scenes != 0) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; if (count == (ssize_t) length) { AcquireNextImage(image_info,image); if (GetNextImageInList(image) == (Image *) NULL) { image=DestroyImageList(image); return((Image *) NULL); } image=SyncNextImageInList(image); status=SetImageProgress(image,LoadImagesTag,TellBlob(image), GetBlobSize(image)); if (status == MagickFalse) break; } scene++; } while (count == (ssize_t) length); quantum_info=DestroyQuantumInfo(quantum_info); InheritException(&image->exception,&canvas_image->exception); canvas_image=DestroyImage(canvas_image); (void) CloseBlob(image); return(GetFirstImageInList(image)); } ",
        "vulrepair": "<Vul_Start> canvas_image=DestroyImage(canvas_image);<Vul_End>"
    },
    {
        "index": 186339,
        "output": "<Vul_Start> ReportPreconnectAccuracy(*it->second, {});<Vul_End><Vul_Start><Vul_End>",
        "label": "<Vul_Start> ReportPreconnectAccuracy(*it->second, {});<Vul_End><Vul_Start><Vul_End>",
        "match": true,
        "source": " void LoadingStatsCollector::RecordPreconnectStats( std::unique_ptr<PreconnectStats> stats) { const GURL& main_frame_url = stats->url; auto it = preconnect_stats_.find(main_frame_url); if (it != preconnect_stats_.end()) { <Vul_Start> ReportPreconnectAccuracy(*it->second, <Vul_End> <Vul_Start> std::map<GURL, OriginRequestSummary>()); <Vul_End> preconnect_stats_.erase(it); } preconnect_stats_.emplace(main_frame_url, std::move(stats)); } ",
        "vulrepair": "<Vul_Start> ReportPreconnectAccuracy(*it->second, std::map<url::Origin, OriginRequestSummary>());<Vul_End><Vul_Start><Vul_End>"
    },
    {
        "index": 182415,
        "output": "<Vul_Start> if (arg >= cdi->capacity)<Vul_End>",
        "label": "<Vul_Start> if (arg >= cdi->capacity)<Vul_End>",
        "match": true,
        "source": " static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi, unsigned long arg) { struct cdrom_changer_info *info; int ret; cd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\"); if (!CDROM_CAN(CDC_MEDIA_CHANGED)) return -ENOSYS; if (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT) return media_changed(cdi, 1); <Vul_Start> if ((unsigned int)arg >= cdi->capacity) <Vul_End> return -EINVAL; info = kmalloc(sizeof(*info), GFP_KERNEL); if (!info) return -ENOMEM; ret = cdrom_read_mech_status(cdi, info); if (!ret) ret = info->slots[arg].change; kfree(info); return ret; } ",
        "vulrepair": "<Vul_Start> if ((unsigned int)arg >= cdi->capacity)<Vul_End>"
    },
    {
        "index": 183281,
        "output": "<Vul_Start> int is_valid = (error == GIT_OK);<Vul_End><Vul_Start><Vul_End>",
        "label": "<Vul_Start> int is_valid = (error == GIT_OK);<Vul_End><Vul_Start><Vul_End>",
        "match": true,
        "source": " static int http_connect(http_subtransport *t) { int error; char *proxy_url; if (t->connected && http_should_keep_alive(&t->parser) && t->parse_finished) return 0; if (t->io) { git_stream_close(t->io); git_stream_free(t->io); t->io = NULL; t->connected = 0; } if (t->connection_data.use_ssl) { error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port); } else { #ifdef GIT_CURL error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port); #else error = git_socket_stream_new(&t->io, t->connection_data.host, t->connection_data.port); #endif } if (error < 0) return error; GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\"); if (git_stream_supports_proxy(t->io) && !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) { error = git_stream_set_proxy(t->io, proxy_url); git__free(proxy_url); if (error < 0) return error; } error = git_stream_connect(t->io); #if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL) if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL && git_stream_is_encrypted(t->io)) { git_cert *cert; <Vul_Start> int is_valid; <Vul_End> if ((error = git_stream_certificate(&cert, t->io)) < 0) return error; giterr_clear(); <Vul_Start> is_valid = error != GIT_ECERTIFICATE; <Vul_End> error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload); if (error < 0) { if (!giterr_last()) giterr_set(GITERR_NET, \"user cancelled certificate check\"); return error; } } #endif if (error < 0) return error; t->connected = 1; return 0; } ",
        "vulrepair": "<Vul_Start> int is_valid = (error == GIT_OK) && (t->connection_data.use_ssl == CURL_CONNECTION_TLS_NONE || error == GIT_SECURE_TRANSPORT);<Vul_End><Vul_Start> is_valid = (error == GIT_OK) && (t->owner->message_type == AUTH_TOKEN) &&<Vul_End>"
    },
    {
        "index": 183040,
        "output": "<Vul_Start> ret = iwl_sta_ucode_activate(priv, sta_id);<Vul_End><Vul_Start><Vul_End>",
        "label": "<Vul_Start> ret = iwl_sta_ucode_activate(priv, sta_id);<Vul_End><Vul_Start><Vul_End>",
        "match": true,
        "source": " static int iwl_process_add_sta_resp(struct iwl_priv *priv, struct iwl_addsta_cmd *addsta, struct iwl_rx_packet *pkt) { u8 sta_id = addsta->sta.sta_id; unsigned long flags; int ret = -EIO; if (pkt->hdr.flags & IWL_CMD_FAILED_MSK) { IWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\", pkt->hdr.flags); return ret; } IWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\", sta_id); spin_lock_irqsave(&priv->shrd->sta_lock, flags); switch (pkt->u.add_sta.status) { case ADD_STA_SUCCESS_MSK: IWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\"); <Vul_Start> iwl_sta_ucode_activate(priv, sta_id); <Vul_End> <Vul_Start> ret = 0; <Vul_End> break; case ADD_STA_NO_ROOM_IN_TABLE: IWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\", sta_id); break; case ADD_STA_NO_BLOCK_ACK_RESOURCE: IWL_ERR(priv, \"Adding station %d failed, no block ack \" \"resource.\\n\", sta_id); break; case ADD_STA_MODIFY_NON_EXIST_STA: IWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\", sta_id); break; default: IWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\", pkt->u.add_sta.status); break; } IWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\", priv->stations[sta_id].sta.mode == STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\", sta_id, priv->stations[sta_id].sta.sta.addr); IWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\", priv->stations[sta_id].sta.mode == STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\", addsta->sta.addr); spin_unlock_irqrestore(&priv->shrd->sta_lock, flags); return ret; } ",
        "vulrepair": "<Vul_Start> iwl_sta_ucode_activate(priv, sta_id);<Vul_End><Vul_Start> ret = iwl_sta_ucode_activate(priv, sta_id);<Vul_End>"
    },
    {
        "index": 181578,
        "output": "<Vul_Start> compact_pixels=AcquireCompactPixels(next_image,exception);<Vul_End>",
        "label": "<Vul_Start> compact_pixels=AcquireCompactPixels(next_image,exception);<Vul_End>",
        "match": true,
        "source": " static size_t WritePSDChannels(const PSDInfo *psd_info, const ImageInfo *image_info,Image *image,Image *next_image, MagickOffsetType size_offset,const MagickBooleanType separate, ExceptionInfo *exception) { Image *mask; MagickOffsetType rows_offset; size_t channels, count, length, offset_length; unsigned char *compact_pixels; count=0; offset_length=0; rows_offset=0; compact_pixels=(unsigned char *) NULL; if (next_image->compression == RLECompression) { <Vul_Start> compact_pixels=AcquireCompactPixels(image,exception); <Vul_End> if (compact_pixels == (unsigned char *) NULL) return(0); } channels=1; if (separate == MagickFalse) { if (next_image->storage_class != PseudoClass) { if (IsImageGray(next_image) == MagickFalse) channels=next_image->colorspace == CMYKColorspace ? 4 : 3; if (next_image->alpha_trait != UndefinedPixelTrait) channels++; } rows_offset=TellBlob(image)+2; count+=WriteCompressionStart(psd_info,image,next_image,channels); offset_length=(next_image->rows*(psd_info->version == 1 ? 2 : 4)); } size_offset+=2; if (next_image->storage_class == PseudoClass) { length=WritePSDChannel(psd_info,image_info,image,next_image, IndexQuantum,compact_pixels,rows_offset,separate,exception); if (separate != MagickFalse) size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2; else rows_offset+=offset_length; count+=length; } else { if (IsImageGray(next_image) != MagickFalse) { length=WritePSDChannel(psd_info,image_info,image,next_image, GrayQuantum,compact_pixels,rows_offset,separate,exception); if (separate != MagickFalse) size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2; else rows_offset+=offset_length; count+=length; } else { if (next_image->colorspace == CMYKColorspace) (void) NegateCMYK(next_image,exception); length=WritePSDChannel(psd_info,image_info,image,next_image, RedQuantum,compact_pixels,rows_offset,separate,exception); if (separate != MagickFalse) size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2; else rows_offset+=offset_length; count+=length; length=WritePSDChannel(psd_info,image_info,image,next_image, GreenQuantum,compact_pixels,rows_offset,separate,exception); if (separate != MagickFalse) size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2; else rows_offset+=offset_length; count+=length; length=WritePSDChannel(psd_info,image_info,image,next_image, BlueQuantum,compact_pixels,rows_offset,separate,exception); if (separate != MagickFalse) size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2; else rows_offset+=offset_length; count+=length; if (next_image->colorspace == CMYKColorspace) { length=WritePSDChannel(psd_info,image_info,image,next_image, BlackQuantum,compact_pixels,rows_offset,separate,exception); if (separate != MagickFalse) size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2; else rows_offset+=offset_length; count+=length; } } if (next_image->alpha_trait != UndefinedPixelTrait) { length=WritePSDChannel(psd_info,image_info,image,next_image, AlphaQuantum,compact_pixels,rows_offset,separate,exception); if (separate != MagickFalse) size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2; else rows_offset+=offset_length; count+=length; } } compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels); if (next_image->colorspace == CMYKColorspace) (void) NegateCMYK(next_image,exception); if (separate != MagickFalse) { const char *property; property=GetImageArtifact(next_image,\"psd:opacity-mask\"); if (property != (const char *) NULL) { mask=(Image *) GetImageRegistry(ImageRegistryType,property, exception); if (mask != (Image *) NULL) { if (mask->compression == RLECompression) { compact_pixels=AcquireCompactPixels(mask,exception); if (compact_pixels == (unsigned char *) NULL) return(0); } length=WritePSDChannel(psd_info,image_info,image,mask, RedQuantum,compact_pixels,rows_offset,MagickTrue,exception); (void) WritePSDSize(psd_info,image,length,size_offset); count+=length; compact_pixels=(unsigned char *) RelinquishMagickMemory( compact_pixels); } } } return(count); } ",
        "vulrepair": "<Vul_Start> compact_pixels=AcquireCompactPixels(next_image,separate,exception);<Vul_End>"
    },
    {
        "index": 178054,
        "output": "<Vul_Start><Vul_End>",
        "label": "<Vul_Start><Vul_End>",
        "match": true,
        "source": " apprentice_load(struct magic_set *ms, const char *fn, int action) { int errs = 0; uint32_t i, j; size_t files = 0, maxfiles = 0; char **filearr = NULL; struct stat st; struct magic_map *map; struct magic_entry_set mset[MAGIC_SETS]; php_stream *dir; php_stream_dirent d; TSRMLS_FETCH(); memset(mset, 0, sizeof(mset)); ms->flags |= MAGIC_CHECK; if ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL) { file_oomem(ms, sizeof(*map)); return NULL; } if (action == FILE_CHECK) (void)fprintf(stderr, \"%s\\n\", usg_hdr); if (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) { int mflen; char mfn[MAXPATHLEN]; dir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL); if (!dir) { errs++; goto out; } while (php_stream_readdir(dir, &d)) { if ((mflen = snprintf(mfn, sizeof(mfn), \"%s/%s\", fn, d.d_name)) < 0) { file_oomem(ms, strlen(fn) + strlen(d.d_name) + 2); errs++; php_stream_closedir(dir); goto out; } if (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) { continue; } if (files >= maxfiles) { size_t mlen; maxfiles = (maxfiles + 1) * 2; mlen = maxfiles * sizeof(*filearr); if ((filearr = CAST(char **, erealloc(filearr, mlen))) == NULL) { file_oomem(ms, mlen); <Vul_Start> efree(mfn); <Vul_End> php_stream_closedir(dir); errs++; goto out; goto out; } } filearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen); } php_stream_closedir(dir); qsort(filearr, files, sizeof(*filearr), cmpstrp); for (i = 0; i < files; i++) { load_1(ms, action, filearr[i], &errs, mset); efree(filearr[i]); } efree(filearr); } else load_1(ms, action, fn, &errs, mset); if (errs) goto out; for (j = 0; j < MAGIC_SETS; j++) { for (i = 0; i < mset[j].count; ) { if (mset[j].me[i].mp->cont_level != 0) { i++; continue; } i = set_text_binary(ms, mset[j].me, mset[j].count, i); } qsort(mset[j].me, mset[j].count, sizeof(*mset[j].me), apprentice_sort); set_last_default(ms, mset[j].me, mset[j].count); if (coalesce_entries(ms, mset[j].me, mset[j].count, &map->magic[j], &map->nmagic[j]) == -1) { errs++; goto out; } } out: for (j = 0; j < MAGIC_SETS; j++) magic_entry_free(mset[j].me, mset[j].count); if (errs) { for (j = 0; j < MAGIC_SETS; j++) { if (map->magic[j]) efree(map->magic[j]); } efree(map); return NULL; } return map; } ",
        "vulrepair": "<Vul_Start> efree(mfn);<Vul_End>"
    },
    {
        "index": 182798,
        "output": "<Vul_Start><Vul_End><Vul_Start><Vul_End>",
        "label": "<Vul_Start><Vul_End><Vul_Start><Vul_End>",
        "match": true,
        "source": " int fpga_reset(void) { <Vul_Start> if (!check_boco2()) { return 0; } printf(\"PCIe reset through GPIO7: \"); <Vul_End> <Vul_Start> kw_gpio_set_valid(KM_PEX_RST_GPIO_PIN, 1); kw_gpio_direction_output(KM_PEX_RST_GPIO_PIN, 1); kw_gpio_set_value(KM_PEX_RST_GPIO_PIN, 0); udelay(1000*10); kw_gpio_set_value(KM_PEX_RST_GPIO_PIN, 1); printf(\" done\\n\"); <Vul_End> return 0; } ",
        "vulrepair": "<Vul_Start> if (!check_boco2()) { return 0; } printf(\"PCIe reset through GPIO7: \");<Vul_End><Vul_Start><Vul_End>"
    },
    {
        "index": 185498,
        "output": "<Vul_Start> time_source_(new base::DefaultTickClock),<Vul_End>",
        "label": "<Vul_Start> time_source_(new base::DefaultTickClock),<Vul_End>",
        "match": true,
        "source": " SchedulerHelper::SchedulerHelper( scoped_refptr<NestableSingleThreadTaskRunner> main_task_runner, const char* tracing_category, const char* disabled_by_default_tracing_category, size_t total_task_queue_count) : task_queue_selector_(new PrioritizingTaskQueueSelector()), task_queue_manager_( new TaskQueueManager(total_task_queue_count, main_task_runner, task_queue_selector_.get(), disabled_by_default_tracing_category)), quiescence_monitored_task_queue_mask_( ((1ull << total_task_queue_count) - 1ull) & ~(1ull << QueueId::CONTROL_TASK_QUEUE) & ~(1ull << QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE)), control_task_runner_( task_queue_manager_->TaskRunnerForQueue(QueueId::CONTROL_TASK_QUEUE)), control_after_wakeup_task_runner_(task_queue_manager_->TaskRunnerForQueue( QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE)), default_task_runner_( task_queue_manager_->TaskRunnerForQueue(QueueId::DEFAULT_TASK_QUEUE)), <Vul_Start> time_source_(new TimeSource), <Vul_End> tracing_category_(tracing_category), disabled_by_default_tracing_category_( disabled_by_default_tracing_category) { DCHECK_GE(total_task_queue_count, static_cast<size_t>(QueueId::TASK_QUEUE_COUNT)); task_queue_selector_->SetQueuePriority( QueueId::CONTROL_TASK_QUEUE, PrioritizingTaskQueueSelector::CONTROL_PRIORITY); task_queue_manager_->SetWakeupPolicy( QueueId::CONTROL_TASK_QUEUE, TaskQueueManager::WakeupPolicy::DONT_WAKE_OTHER_QUEUES); task_queue_selector_->SetQueuePriority( QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE, PrioritizingTaskQueueSelector::CONTROL_PRIORITY); task_queue_manager_->SetPumpPolicy( QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE, TaskQueueManager::PumpPolicy::AFTER_WAKEUP); task_queue_manager_->SetWakeupPolicy( QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE, TaskQueueManager::WakeupPolicy::DONT_WAKE_OTHER_QUEUES); for (size_t i = 0; i < TASK_QUEUE_COUNT; i++) { task_queue_manager_->SetQueueName( i, TaskQueueIdToString(static_cast<QueueId>(i))); } task_queue_manager_->SetWorkBatchSize(1); } ",
        "vulrepair": "<Vul_Start><Vul_End>"
    },
    {
        "index": 184259,
        "output": "<Vul_Start> void BlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)<Vul_End><Vul_Start> if (isMainThread()) { if (WebBlobRegistry* registry = blobRegistry())<Vul_End><Vul_Start> registry->registerBlobURL(url, srcURL);<Vul_End><Vul_Start> } else {<Vul_End>",
        "label": "<Vul_Start> void BlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)<Vul_End><Vul_Start> if (isMainThread()) { if (WebBlobRegistry* registry = blobRegistry())<Vul_End><Vul_Start> registry->registerBlobURL(url, srcURL);<Vul_End><Vul_Start> } else {<Vul_End>",
        "match": true,
        "source": " void ThreadableBlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL) <Vul_Start><Vul_End> { if (origin && BlobURL::getOrigin(url) == \"null\") originMap()->add(url.string(), origin); <Vul_Start> if (isMainThread()) <Vul_End> <Vul_Start> blobRegistry().registerBlobURL(url, srcURL); <Vul_End> <Vul_Start> else { <Vul_End> OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, srcURL)); callOnMainThread(&registerBlobURLFromTask, context.leakPtr()); } } ",
        "vulrepair": "<Vul_Start> void BlobRegistry::registerBlobURL(const KURL& url, const KURL& srcURL)<Vul_End><Vul_Start> if (isMainThread()) { if (WebBlobRegistry* registry = blobRegistry())<Vul_End><Vul_Start> registry->registerBlobURL(url, srcURL);<Vul_End><Vul_Start><Vul_End>"
    },
    {
        "index": 182140,
        "output": "<Vul_Start> strncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));<Vul_End><Vul_Start> strncpy(ualg->cru_driver_name, alg->cra_driver_name,<Vul_End><Vul_Start> strncpy(ualg->cru_module_name, module_name(alg->cra_module),<Vul_End><Vul_Start> strncpy(rl.type, \"larval\", sizeof(rl.type));<Vul_End>",
        "label": "<Vul_Start> strncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));<Vul_End><Vul_Start> strncpy(ualg->cru_driver_name, alg->cra_driver_name,<Vul_End><Vul_Start> strncpy(ualg->cru_module_name, module_name(alg->cra_module),<Vul_End><Vul_Start> strncpy(rl.type, \"larval\", sizeof(rl.type));<Vul_End>",
        "match": true,
        "source": " static int crypto_report_one(struct crypto_alg *alg, struct crypto_user_alg *ualg, struct sk_buff *skb) { <Vul_Start> strlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name)); <Vul_End> <Vul_Start> strlcpy(ualg->cru_driver_name, alg->cra_driver_name, <Vul_End> sizeof(ualg->cru_driver_name)); <Vul_Start> strlcpy(ualg->cru_module_name, module_name(alg->cra_module), <Vul_End> sizeof(ualg->cru_module_name)); ualg->cru_type = 0; ualg->cru_mask = 0; ualg->cru_flags = alg->cra_flags; ualg->cru_refcnt = refcount_read(&alg->cra_refcnt); if (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority)) goto nla_put_failure; if (alg->cra_flags & CRYPTO_ALG_LARVAL) { struct crypto_report_larval rl; <Vul_Start> strlcpy(rl.type, \"larval\", sizeof(rl.type)); <Vul_End> if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL, sizeof(struct crypto_report_larval), &rl)) goto nla_put_failure; goto out; } if (alg->cra_type && alg->cra_type->report) { if (alg->cra_type->report(skb, alg)) goto nla_put_failure; goto out; } switch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) { case CRYPTO_ALG_TYPE_CIPHER: if (crypto_report_cipher(skb, alg)) goto nla_put_failure; break; case CRYPTO_ALG_TYPE_COMPRESS: if (crypto_report_comp(skb, alg)) goto nla_put_failure; break; case CRYPTO_ALG_TYPE_ACOMPRESS: if (crypto_report_acomp(skb, alg)) goto nla_put_failure; break; case CRYPTO_ALG_TYPE_AKCIPHER: if (crypto_report_akcipher(skb, alg)) goto nla_put_failure; break; case CRYPTO_ALG_TYPE_KPP: if (crypto_report_kpp(skb, alg)) goto nla_put_failure; break; } out: return 0; nla_put_failure: return -EMSGSIZE; } ",
        "vulrepair": "<Vul_Start> strncpy(ualg->cru_name, alg->cra_name,<Vul_End><Vul_Start> strncpy(ualg->cru_driver_name, alg->cra_driver_name,<Vul_End><Vul_Start> module_name(alg->cra_module),<Vul_End><Vul_Start> strncpy(ualg->cru_module_name, module_name(alg->cra_module),<Vul_End>"
    },
    {
        "index": 187557,
        "output": "<Vul_Start> BufferMeta *bufferMeta = new BufferMeta(graphicBuffer, portIndex);<Vul_End>",
        "label": "<Vul_Start> BufferMeta *bufferMeta = new BufferMeta(graphicBuffer, portIndex);<Vul_End>",
        "match": true,
        "source": " status_t OMXNodeInstance::useGraphicBuffer2_l( OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer, OMX::buffer_id *buffer) { OMX_PARAM_PORTDEFINITIONTYPE def; InitOMXParams(&def); def.nPortIndex = portIndex; OMX_ERRORTYPE err = OMX_GetParameter(mHandle, OMX_IndexParamPortDefinition, &def); if (err != OMX_ErrorNone) { OMX_INDEXTYPE index = OMX_IndexParamPortDefinition; CLOG_ERROR(getParameter, err, \"%s(%#x): %s:%u\", asString(index), index, portString(portIndex), portIndex); return UNKNOWN_ERROR; } <Vul_Start> BufferMeta *bufferMeta = new BufferMeta(graphicBuffer); <Vul_End> OMX_BUFFERHEADERTYPE *header = NULL; OMX_U8* bufferHandle = const_cast<OMX_U8*>( reinterpret_cast<const OMX_U8*>(graphicBuffer->handle)); err = OMX_UseBuffer( mHandle, &header, portIndex, bufferMeta, def.nBufferSize, bufferHandle); if (err != OMX_ErrorNone) { CLOG_ERROR(useBuffer, err, BUFFER_FMT(portIndex, \"%u@%p\", def.nBufferSize, bufferHandle)); delete bufferMeta; bufferMeta = NULL; *buffer = 0; return StatusFromOMXError(err); } CHECK_EQ(header->pBuffer, bufferHandle); CHECK_EQ(header->pAppPrivate, bufferMeta); *buffer = makeBufferID(header); addActiveBuffer(portIndex, *buffer); CLOG_BUFFER(useGraphicBuffer2, NEW_BUFFER_FMT( *buffer, portIndex, \"%u@%p\", def.nBufferSize, bufferHandle)); return OK; } ",
        "vulrepair": "<Vul_Start> BufferMeta *bufferMeta = new BufferMeta(graphicBuffer->nBufferSize);<Vul_End>"
    },
    {
        "index": 181992,
        "output": "<Vul_Start> if (_gdImageWebpCtx(im, out, quality)) { rv = NULL; } else {<Vul_End><Vul_Start> rv = gdDPExtractData(out, size); }<Vul_End>",
        "label": "<Vul_Start> if (_gdImageWebpCtx(im, out, quality)) { rv = NULL; } else {<Vul_End><Vul_Start> rv = gdDPExtractData(out, size); }<Vul_End>",
        "match": true,
        "source": " BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality) { void *rv; gdIOCtx *out = gdNewDynamicCtx(2048, NULL); if (out == NULL) { return NULL; } <Vul_Start> gdImageWebpCtx(im, out, quality); <Vul_End> <Vul_Start> rv = gdDPExtractData(out, size); <Vul_End> out->gd_free(out); return rv; } ",
        "vulrepair": "<Vul_Start> if (_gdImageWebpCtx(im, out, quality) < 0) { return NULL; } rv = gdDPExtractData(out, size); } else { rv = NULL; }<Vul_End><Vul_Start> if (!rv) {<Vul_End>"
    },
    {
        "index": 180428,
        "output": "<Vul_Start><Vul_End>",
        "label": "<Vul_Start><Vul_End>",
        "match": true,
        "source": " static int replace_map_fd_with_map_ptr(struct verifier_env *env) { struct bpf_insn *insn = env->prog->insnsi; int insn_cnt = env->prog->len; int i, j; for (i = 0; i < insn_cnt; i++, insn++) { if (BPF_CLASS(insn->code) == BPF_LDX && (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) { verbose(\"BPF_LDX uses reserved fields\\n\"); return -EINVAL; } if (BPF_CLASS(insn->code) == BPF_STX && ((BPF_MODE(insn->code) != BPF_MEM && BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) { verbose(\"BPF_STX uses reserved fields\\n\"); return -EINVAL; } if (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) { struct bpf_map *map; struct fd f; if (i == insn_cnt - 1 || insn[1].code != 0 || insn[1].dst_reg != 0 || insn[1].src_reg != 0 || insn[1].off != 0) { verbose(\"invalid bpf_ld_imm64 insn\\n\"); return -EINVAL; } if (insn->src_reg == 0) goto next_insn; if (insn->src_reg != BPF_PSEUDO_MAP_FD) { verbose(\"unrecognized bpf_ld_imm64 insn\\n\"); return -EINVAL; } f = fdget(insn->imm); map = __bpf_map_get(f); if (IS_ERR(map)) { verbose(\"fd %d is not pointing to valid bpf_map\\n\", insn->imm); <Vul_Start> fdput(f); <Vul_End> return PTR_ERR(map); } insn[0].imm = (u32) (unsigned long) map; insn[1].imm = ((u64) (unsigned long) map) >> 32; for (j = 0; j < env->used_map_cnt; j++) if (env->used_maps[j] == map) { fdput(f); goto next_insn; } if (env->used_map_cnt >= MAX_USED_MAPS) { fdput(f); return -E2BIG; } env->used_maps[env->used_map_cnt++] = map; bpf_map_inc(map, false); fdput(f); next_insn: insn++; i++; } } return 0; } ",
        "vulrepair": "<Vul_Start> __bpf_map_put(f);<Vul_End>"
    },
    {
        "index": 179575,
        "output": "<Vul_Start> check_stack_depth(); <Vul_End>",
        "label": "<Vul_Start> check_stack_depth(); <Vul_End>",
        "match": true,
        "source": " findoprnd(ITEM *ptr, int32 *pos) { <Vul_Start><Vul_End> #ifdef BS_DEBUG elog(DEBUG3, (ptr[*pos].type == OPR) ? \"%d %c\" : \"%d %d\", *pos, ptr[*pos].val); #endif if (ptr[*pos].type == VAL) { ptr[*pos].left = 0; (*pos)--; } else if (ptr[*pos].val == (int32) '!') { ptr[*pos].left = -1; (*pos)--; findoprnd(ptr, pos); } else { ITEM *curitem = &ptr[*pos]; int32 tmp = *pos; (*pos)--; findoprnd(ptr, pos); curitem->left = *pos - tmp; findoprnd(ptr, pos); } } ",
        "vulrepair": "<Vul_Start> if (*pos < 0) return;<Vul_End>"
    },
    {
        "index": 182077,
        "output": "<Vul_Start> static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info, int pixel_size,ExceptionInfo *exception)<Vul_End><Vul_Start> if (EOFBlob(image)!= MagickFalse) { ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\", image->filename); return(MagickFalse); }<Vul_End><Vul_Start> return(MagickTrue);<Vul_End>",
        "label": "<Vul_Start> static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info, int pixel_size,ExceptionInfo *exception)<Vul_End><Vul_Start> if (EOFBlob(image)!= MagickFalse) { ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\", image->filename); return(MagickFalse); }<Vul_End><Vul_Start> return(MagickTrue);<Vul_End>",
        "match": true,
        "source": " static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size) <Vul_Start><Vul_End> { MagickOffsetType offset; register ssize_t i; size_t h, w; if (dds_info->ddscaps1 & DDSCAPS_MIPMAP && (dds_info->ddscaps1 & DDSCAPS_TEXTURE || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP)) { <Vul_Start><Vul_End> w = DIV2(dds_info->width); h = DIV2(dds_info->height); for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++) { offset = (MagickOffsetType) w * h * pixel_size; (void) SeekBlob(image, offset, SEEK_CUR); w = DIV2(w); h = DIV2(h); } } <Vul_Start><Vul_End> } ",
        "vulrepair": "<Vul_Start> static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info, int pixel_size,int littleendian)<Vul_End><Vul_Start> if (littleendian) { if (image->columns > 255) break; }<Vul_End><Vul_Start> return MagickFalse;<Vul_End>"
    },
    {
        "index": 185220,
        "output": "<Vul_Start> TabDetachedAt(removed_contents->web_contents(), index));<Vul_End>",
        "label": "<Vul_Start> TabDetachedAt(removed_contents->web_contents(), index));<Vul_End>",
        "match": true,
        "source": " TabContents* TabStripModel::DetachTabContentsAt(int index) { if (contents_data_.empty()) return NULL; DCHECK(ContainsIndex(index)); TabContents* removed_contents = GetTabContentsAtImpl(index); bool was_selected = IsTabSelected(index); int next_selected_index = order_controller_->DetermineNewSelectedIndex(index); delete contents_data_[index]; contents_data_.erase(contents_data_.begin() + index); ForgetOpenersAndGroupsReferencing(removed_contents->web_contents()); if (empty()) closing_all_ = true; FOR_EACH_OBSERVER(TabStripModelObserver, observers_, <Vul_Start> TabDetachedAt(removed_contents, index)); <Vul_End> if (empty()) { selection_model_.Clear(); FOR_EACH_OBSERVER(TabStripModelObserver, observers_, TabStripEmpty()); } else { int old_active = active_index(); selection_model_.DecrementFrom(index); TabStripSelectionModel old_model; old_model.Copy(selection_model_); if (index == old_active) { NotifyIfTabDeactivated(removed_contents); if (!selection_model_.empty()) { selection_model_.set_active(selection_model_.selected_indices()[0]); selection_model_.set_anchor(selection_model_.active()); } else { selection_model_.SetSelectedIndex(next_selected_index); } NotifyIfActiveTabChanged(removed_contents, NOTIFY_DEFAULT); } if (was_selected) { FOR_EACH_OBSERVER(TabStripModelObserver, observers_, TabSelectionChanged(this, old_model)); } } return removed_contents; } ",
        "vulrepair": "<Vul_Start> TabDetachedAt(removed_contents));<Vul_End>"
    },
    {
        "index": 181526,
        "output": "<Vul_Start> alloc_limit_failure (fn_name, size);<Vul_End><Vul_Start> exit (-1);<Vul_End>",
        "label": "<Vul_Start> alloc_limit_failure (fn_name, size);<Vul_End><Vul_Start> exit (-1);<Vul_End>",
        "match": true,
        "source": " alloc_limit_assert (char *fn_name, size_t size) { if (alloc_limit && size > alloc_limit) { <Vul_Start> alloc_limit_failure (fn_name, size); <Vul_End> <Vul_Start> exit (-1); <Vul_End> } } ",
        "vulrepair": "<Vul_Start> alloc_limit_failure (fn_name, -1);<Vul_End><Vul_Start><Vul_End>"
    },
    {
        "index": 188570,
        "output": "<Vul_Start> DECLARE_ALIGNED(16, int16_t, input_block[kNumCoeffs]);<Vul_End><Vul_Start> DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);<Vul_End><Vul_Start> DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);<Vul_End><Vul_Start> <Vul_End><Vul_Start> input_block[j] = (rnd.Rand16() & mask_) - (rnd.Rand16() & mask_);<Vul_End><Vul_Start> ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));<Vul_End>",
        "label": "<Vul_Start> DECLARE_ALIGNED(16, int16_t, input_block[kNumCoeffs]);<Vul_End><Vul_Start> DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);<Vul_End><Vul_Start> DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);<Vul_End><Vul_Start> <Vul_End><Vul_Start> input_block[j] = (rnd.Rand16() & mask_) - (rnd.Rand16() & mask_);<Vul_End><Vul_Start> ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));<Vul_End>",
        "match": true,
        "source": " void RunCoeffCheck() { ACMRandom rnd(ACMRandom::DeterministicSeed()); const int count_test_block = 5000; <Vul_Start> DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs); <Vul_End> <Vul_Start> DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs); <Vul_End> <Vul_Start> DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs); <Vul_End> for (int i = 0; i < count_test_block; ++i) { <Vul_Start><Vul_End> for (int j = 0; j < kNumCoeffs; ++j) <Vul_Start> input_block[j] = rnd.Rand8() - rnd.Rand8(); <Vul_End> fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_); <Vul_Start> REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_)); <Vul_End> for (int j = 0; j < kNumCoeffs; ++j) EXPECT_EQ(output_block[j], output_ref_block[j]); } } ",
        "vulrepair": "<Vul_Start> DECLARE_ALIGNED(16, int16_t, input_block[kNumCoeffs]);<Vul_End><Vul_Start> DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);<Vul_End><Vul_Start> DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);<Vul_End><Vul_Start> DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);<Vul_End><Vul_Start> ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));<Vul_End>"
    },
    {
        "index": 186906,
        "output": "<Vul_Start><Vul_End>",
        "label": "<Vul_Start><Vul_End>",
        "match": true,
        "source": " inline HTMLIFrameElement::HTMLIFrameElement(Document& document) : HTMLFrameElementBase(iframeTag, document), <Vul_Start> did_load_non_empty_document_(false), <Vul_End> collapsed_by_client_(false), sandbox_(HTMLIFrameElementSandbox::Create(this)), referrer_policy_(kReferrerPolicyDefault) {} ",
        "vulrepair": "<Vul_Start> did_load_non_empty_document_(false),<Vul_End>"
    },
    {
        "index": 179651,
        "output": "<Vul_Start><Vul_End><Vul_Start> *addr_len = sizeof(*sin);<Vul_End>",
        "label": "<Vul_Start><Vul_End><Vul_Start> *addr_len = sizeof(*sin);<Vul_End>",
        "match": true,
        "source": " int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len, int noblock, int flags, int *addr_len) { struct inet_sock *inet = inet_sk(sk); struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name; struct sk_buff *skb; unsigned int ulen, copied; int peeked, off = 0; int err; int is_udplite = IS_UDPLITE(sk); bool slow; <Vul_Start> if (addr_len) *addr_len = sizeof(*sin); <Vul_End> if (flags & MSG_ERRQUEUE) return ip_recv_error(sk, msg, len); try_again: skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0), &peeked, &off, &err); if (!skb) goto out; ulen = skb->len - sizeof(struct udphdr); copied = len; if (copied > ulen) copied = ulen; else if (copied < ulen) msg->msg_flags |= MSG_TRUNC; if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) { if (udp_lib_checksum_complete(skb)) goto csum_copy_err; } if (skb_csum_unnecessary(skb)) err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr), msg->msg_iov, copied); else { err = skb_copy_and_csum_datagram_iovec(skb, sizeof(struct udphdr), msg->msg_iov); if (err == -EINVAL) goto csum_copy_err; } if (unlikely(err)) { trace_kfree_skb(skb, udp_recvmsg); if (!peeked) { atomic_inc(&sk->sk_drops); UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite); } goto out_free; } if (!peeked) UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INDATAGRAMS, is_udplite); sock_recv_ts_and_drops(msg, sk, skb); if (sin) { sin->sin_family = AF_INET; sin->sin_port = udp_hdr(skb)->source; sin->sin_addr.s_addr = ip_hdr(skb)->saddr; memset(sin->sin_zero, 0, sizeof(sin->sin_zero)); <Vul_Start><Vul_End> } if (inet->cmsg_flags) ip_cmsg_recv(msg, skb); err = copied; if (flags & MSG_TRUNC) err = ulen; out_free: skb_free_datagram_locked(sk, skb); out: return err; csum_copy_err: slow = lock_sock_fast(sk); if (!skb_kill_datagram(sk, skb, flags)) { UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite); UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite); } unlock_sock_fast(sk, slow); if (noblock) return -EAGAIN; msg->msg_flags &= ~MSG_TRUNC; goto try_again; } ",
        "vulrepair": "<Vul_Start><Vul_End><Vul_Start><Vul_End>"
    },
    {
        "index": 178859,
        "output": "<Vul_Start> static int can_open_delegated(struct nfs_delegation *delegation, fmode_t fmode)<Vul_End><Vul_Start> if ((delegation->type & fmode)!= fmode)<Vul_End>",
        "label": "<Vul_Start> static int can_open_delegated(struct nfs_delegation *delegation, fmode_t fmode)<Vul_End><Vul_Start> if ((delegation->type & fmode)!= fmode)<Vul_End>",
        "match": true,
        "source": " static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags) <Vul_Start><Vul_End> { <Vul_Start> if ((delegation->type & open_flags) != open_flags) <Vul_End> return 0; if (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags)) return 0; nfs_mark_delegation_referenced(delegation); return 1; } ",
        "vulrepair": "<Vul_Start> static int can_open_delegated(struct nfs_server *server, fmode_t fmode)<Vul_End><Vul_Start> if ((delegation->type & fmode)!= fmode)<Vul_End>"
    },
    {
        "index": 181154,
        "output": "<Vul_Start> if ((i < 0) || (i >= MNG_MAX_OBJECTS)) continue;<Vul_End>",
        "label": "<Vul_Start> if ((i < 0) || (i >= MNG_MAX_OBJECTS)) continue;<Vul_End>",
        "match": true,
        "source": " static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info, ExceptionInfo *exception) { char page_geometry[MaxTextExtent]; Image *image; MagickBooleanType logging; volatile int first_mng_object, object_id, term_chunk_found, skip_to_iend; volatile ssize_t image_count=0; MagickBooleanType status; MagickOffsetType offset; MngBox default_fb, fb, previous_fb; #if defined(MNG_INSERT_LAYERS) PixelPacket mng_background_color; #endif register unsigned char *p; register ssize_t i; size_t count; ssize_t loop_level; volatile short skipping_loop; #if defined(MNG_INSERT_LAYERS) unsigned int mandatory_back=0; #endif volatile unsigned int #ifdef MNG_OBJECT_BUFFERS mng_background_object=0, #endif mng_type=0; size_t default_frame_timeout, frame_timeout, #if defined(MNG_INSERT_LAYERS) image_height, image_width, #endif length; volatile size_t default_frame_delay, final_delay, final_image_delay, frame_delay, #if defined(MNG_INSERT_LAYERS) insert_layers, #endif mng_iterations=1, simplicity=0, subframe_height=0, subframe_width=0; previous_fb.top=0; previous_fb.bottom=0; previous_fb.left=0; previous_fb.right=0; default_fb.top=0; default_fb.bottom=0; default_fb.left=0; default_fb.right=0; logging=LogMagickEvent(CoderEvent,GetMagickModule(), \" Enter ReadOneMNGImage()\"); image=mng_info->image; if (LocaleCompare(image_info->magick,\"MNG\") == 0) { char magic_number[MaxTextExtent]; count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number); if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); for (i=0; i < MNG_MAX_OBJECTS; i++) { mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX; mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX; } mng_info->exists[0]=MagickTrue; } skipping_loop=(-1); first_mng_object=MagickTrue; mng_type=0; #if defined(MNG_INSERT_LAYERS) insert_layers=MagickFalse; #endif default_frame_delay=0; default_frame_timeout=0; frame_delay=0; final_delay=1; mng_info->ticks_per_second=1UL*image->ticks_per_second; object_id=0; skip_to_iend=MagickFalse; term_chunk_found=MagickFalse; mng_info->framing_mode=1; #if defined(MNG_INSERT_LAYERS) mandatory_back=MagickFalse; #endif #if defined(MNG_INSERT_LAYERS) mng_background_color=image->background_color; #endif default_fb=mng_info->frame; previous_fb=mng_info->frame; do { char type[MaxTextExtent]; if (LocaleCompare(image_info->magick,\"MNG\") == 0) { unsigned char *chunk; type[0]='\\0'; (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent); length=ReadBlobMSBLong(image); count=(size_t) ReadBlob(image,4,(unsigned char *) type); if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Reading MNG chunk type %c%c%c%c, length: %.20g\", type[0],type[1],type[2],type[3],(double) length); if (length > PNG_UINT_31_MAX) { status=MagickFalse; break; } if (count == 0) ThrowReaderException(CorruptImageError,\"CorruptImage\"); p=NULL; chunk=(unsigned char *) NULL; if (length != 0) { chunk=(unsigned char *) AcquireQuantumMemory(length+ MagickPathExtent,sizeof(*chunk)); if (chunk == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"); for (i=0; i < (ssize_t) length; i++) { int c; c=ReadBlobByte(image); if (c == EOF) break; chunk[i]=(unsigned char) c; } p=chunk; } (void) ReadBlobMSBLong(image); #if !defined(JNG_SUPPORTED) if (memcmp(type,mng_JHDR,4) == 0) { skip_to_iend=MagickTrue; if (mng_info->jhdr_warning == 0) (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename); mng_info->jhdr_warning++; } #endif if (memcmp(type,mng_DHDR,4) == 0) { skip_to_iend=MagickTrue; if (mng_info->dhdr_warning == 0) (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename); mng_info->dhdr_warning++; } if (memcmp(type,mng_MEND,4) == 0) break; if (skip_to_iend) { if (memcmp(type,mng_IEND,4) == 0) skip_to_iend=MagickFalse; if (length != 0) chunk=(unsigned char *) RelinquishMagickMemory(chunk); if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Skip to IEND.\"); continue; } if (memcmp(type,mng_MHDR,4) == 0) { if (length != 28) { chunk=(unsigned char *) RelinquishMagickMemory(chunk); ThrowReaderException(CorruptImageError,\"CorruptImage\"); } mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]); mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) | (p[6] << 8) | p[7]); if (logging != MagickFalse) { (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" MNG width: %.20g\",(double) mng_info->mng_width); (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" MNG height: %.20g\",(double) mng_info->mng_height); } p+=8; mng_info->ticks_per_second=(size_t) mng_get_long(p); if (mng_info->ticks_per_second == 0) default_frame_delay=0; else default_frame_delay=1UL*image->ticks_per_second/ mng_info->ticks_per_second; frame_delay=default_frame_delay; simplicity=0; p+=16; simplicity=(size_t) mng_get_long(p); mng_type=1; if ((simplicity != 0) && ((simplicity | 11) == 11)) mng_type=2; if ((simplicity != 0) && ((simplicity | 9) == 9)) mng_type=3; #if defined(MNG_INSERT_LAYERS) if (mng_type != 3) insert_layers=MagickTrue; #endif if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL) { AcquireNextImage(image_info,image); if (GetNextImageInList(image) == (Image *) NULL) return(DestroyImageList(image)); image=SyncNextImageInList(image); mng_info->image=image; } if ((mng_info->mng_width > 65535L) || (mng_info->mng_height > 65535L)) { chunk=(unsigned char *) RelinquishMagickMemory(chunk); ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\"); } (void) FormatLocaleString(page_geometry,MaxTextExtent, \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double) mng_info->mng_height); mng_info->frame.left=0; mng_info->frame.right=(ssize_t) mng_info->mng_width; mng_info->frame.top=0; mng_info->frame.bottom=(ssize_t) mng_info->mng_height; mng_info->clip=default_fb=previous_fb=mng_info->frame; for (i=0; i < MNG_MAX_OBJECTS; i++) mng_info->object_clip[i]=mng_info->frame; chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_TERM,4) == 0) { int repeat=0; if (length != 0) repeat=p[0]; if (repeat == 3 && length > 8) { final_delay=(png_uint_32) mng_get_long(&p[2]); mng_iterations=(png_uint_32) mng_get_long(&p[6]); if (mng_iterations == PNG_UINT_31_MAX) mng_iterations=0; image->iterations=mng_iterations; term_chunk_found=MagickTrue; } if (logging != MagickFalse) { (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" repeat=%d, final_delay=%.20g, iterations=%.20g\", repeat,(double) final_delay, (double) image->iterations); } chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_DEFI,4) == 0) { if (mng_type == 3) (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\", image->filename); if (length > 1) { object_id=(p[0] << 8) | p[1]; if (mng_type == 2 && object_id != 0) (void) ThrowMagickException(&image->exception, GetMagickModule(), CoderError,\"Nonzero object_id in MNG-LC datastream\", \"`%s'\", image->filename); if (object_id > MNG_MAX_OBJECTS) { (void) ThrowMagickException(&image->exception, GetMagickModule(), CoderError, \"object id too large\",\"`%s'\",image->filename); object_id=MNG_MAX_OBJECTS; } if (mng_info->exists[object_id]) if (mng_info->frozen[object_id]) { chunk=(unsigned char *) RelinquishMagickMemory(chunk); (void) ThrowMagickException(&image->exception, GetMagickModule(),CoderError, \"DEFI cannot redefine a frozen MNG object\",\"`%s'\", image->filename); continue; } mng_info->exists[object_id]=MagickTrue; if (length > 2) mng_info->invisible[object_id]=p[2]; if (length > 11) { mng_info->x_off[object_id]=(ssize_t) ((p[4] << 24) | (p[5] << 16) | (p[6] << 8) | p[7]); mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) | (p[9] << 16) | (p[10] << 8) | p[11]); if (logging != MagickFalse) { (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" x_off[%d]: %.20g, y_off[%d]: %.20g\", object_id,(double) mng_info->x_off[object_id], object_id,(double) mng_info->y_off[object_id]); } } if (length > 27) mng_info->object_clip[object_id]= mng_read_box(mng_info->frame,0, &p[12]); } chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_bKGD,4) == 0) { mng_info->have_global_bkgd=MagickFalse; if (length > 5) { mng_info->mng_global_bkgd.red= ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1])); mng_info->mng_global_bkgd.green= ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3])); mng_info->mng_global_bkgd.blue= ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5])); mng_info->have_global_bkgd=MagickTrue; } chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_BACK,4) == 0) { #if defined(MNG_INSERT_LAYERS) if (length > 6) mandatory_back=p[6]; else mandatory_back=0; if (mandatory_back && length > 5) { mng_background_color.red= ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1])); mng_background_color.green= ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3])); mng_background_color.blue= ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5])); mng_background_color.opacity=OpaqueOpacity; } #ifdef MNG_OBJECT_BUFFERS if (length > 8) mng_background_object=(p[7] << 8) | p[8]; #endif #endif chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_PLTE,4) == 0) { if (length && (length < 769)) { if (mng_info->global_plte == (png_colorp) NULL) mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256, sizeof(*mng_info->global_plte)); for (i=0; i < (ssize_t) (length/3); i++) { mng_info->global_plte[i].red=p[3*i]; mng_info->global_plte[i].green=p[3*i+1]; mng_info->global_plte[i].blue=p[3*i+2]; } mng_info->global_plte_length=(unsigned int) (length/3); } #ifdef MNG_LOOSE for ( ; i < 256; i++) { mng_info->global_plte[i].red=i; mng_info->global_plte[i].green=i; mng_info->global_plte[i].blue=i; } if (length != 0) mng_info->global_plte_length=256; #endif else mng_info->global_plte_length=0; chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_tRNS,4) == 0) { if (length > 0 && length < 257) for (i=0; i < (ssize_t) length; i++) mng_info->global_trns[i]=p[i]; #ifdef MNG_LOOSE for ( ; i < 256; i++) mng_info->global_trns[i]=255; #endif mng_info->global_trns_length=(unsigned int) length; chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_gAMA,4) == 0) { if (length == 4) { ssize_t igamma; igamma=mng_get_long(p); mng_info->global_gamma=((float) igamma)*0.00001; mng_info->have_global_gama=MagickTrue; } else mng_info->have_global_gama=MagickFalse; chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_cHRM,4) == 0) { if (length == 32) { mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p); mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]); mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]); mng_info->global_chrm.red_primary.y=0.00001* mng_get_long(&p[12]); mng_info->global_chrm.green_primary.x=0.00001* mng_get_long(&p[16]); mng_info->global_chrm.green_primary.y=0.00001* mng_get_long(&p[20]); mng_info->global_chrm.blue_primary.x=0.00001* mng_get_long(&p[24]); mng_info->global_chrm.blue_primary.y=0.00001* mng_get_long(&p[28]); mng_info->have_global_chrm=MagickTrue; } else mng_info->have_global_chrm=MagickFalse; chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_sRGB,4) == 0) { if (length != 0) { mng_info->global_srgb_intent= Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]); mng_info->have_global_srgb=MagickTrue; } else mng_info->have_global_srgb=MagickFalse; chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_iCCP,4) == 0) { if (length != 0) chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_FRAM,4) == 0) { if (mng_type == 3) (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\", image->filename); if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4)) image->delay=frame_delay; frame_delay=default_frame_delay; frame_timeout=default_frame_timeout; fb=default_fb; if (length > 0) if (p[0]) mng_info->framing_mode=p[0]; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Framing_mode=%d\",mng_info->framing_mode); if (length > 6) { p++; while (*p && ((p-chunk) < (ssize_t) length)) p++; p++; if ((p-chunk) < (ssize_t) (length-4)) { int change_delay, change_timeout, change_clipping; change_delay=(*p++); change_timeout=(*p++); change_clipping=(*p++); p++; if (change_delay && (p-chunk) < (ssize_t) (length-4)) { frame_delay=1UL*image->ticks_per_second* mng_get_long(p); if (mng_info->ticks_per_second != 0) frame_delay/=mng_info->ticks_per_second; else frame_delay=PNG_UINT_31_MAX; if (change_delay == 2) default_frame_delay=frame_delay; p+=4; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Framing_delay=%.20g\",(double) frame_delay); } if (change_timeout && (p-chunk) < (ssize_t) (length-4)) { frame_timeout=1UL*image->ticks_per_second* mng_get_long(p); if (mng_info->ticks_per_second != 0) frame_timeout/=mng_info->ticks_per_second; else frame_timeout=PNG_UINT_31_MAX; if (change_timeout == 2) default_frame_timeout=frame_timeout; p+=4; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Framing_timeout=%.20g\",(double) frame_timeout); } if (change_clipping && (p-chunk) < (ssize_t) (length-17)) { fb=mng_read_box(previous_fb,(char) p[0],&p[1]); p+=17; previous_fb=fb; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\", (double) fb.left,(double) fb.right,(double) fb.top, (double) fb.bottom); if (change_clipping == 2) default_fb=fb; } } } mng_info->clip=fb; mng_info->clip=mng_minimum_box(fb,mng_info->frame); subframe_width=(size_t) (mng_info->clip.right -mng_info->clip.left); subframe_height=(size_t) (mng_info->clip.bottom -mng_info->clip.top); #if defined(MNG_INSERT_LAYERS) if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" subframe_width=%.20g, subframe_height=%.20g\",(double) subframe_width,(double) subframe_height); if (insert_layers && (mng_info->framing_mode == 4) && (subframe_width) && (subframe_height)) { if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL) { AcquireNextImage(image_info,image); if (GetNextImageInList(image) == (Image *) NULL) return(DestroyImageList(image)); image=SyncNextImageInList(image); } mng_info->image=image; if (term_chunk_found) { image->start_loop=MagickTrue; image->iterations=mng_iterations; term_chunk_found=MagickFalse; } else image->start_loop=MagickFalse; image->columns=subframe_width; image->rows=subframe_height; image->page.width=subframe_width; image->page.height=subframe_height; image->page.x=mng_info->clip.left; image->page.y=mng_info->clip.top; image->background_color=mng_background_color; image->matte=MagickFalse; image->delay=0; (void) SetImageBackgroundColor(image); if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\", (double) mng_info->clip.left,(double) mng_info->clip.right, (double) mng_info->clip.top,(double) mng_info->clip.bottom); } #endif chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_CLIP,4) == 0) { unsigned int first_object, last_object; if (length > 3) { first_object=(p[0] << 8) | p[1]; last_object=(p[2] << 8) | p[3]; p+=4; for (i=(int) first_object; i <= (int) last_object; i++) { if (mng_info->exists[i] && !mng_info->frozen[i]) { MngBox box; box=mng_info->object_clip[i]; if ((p-chunk) < (ssize_t) (length-17)) mng_info->object_clip[i]= mng_read_box(box,(char) p[0],&p[1]); } } } chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_SAVE,4) == 0) { for (i=1; i < MNG_MAX_OBJECTS; i++) if (mng_info->exists[i]) { mng_info->frozen[i]=MagickTrue; #ifdef MNG_OBJECT_BUFFERS if (mng_info->ob[i] != (MngBuffer *) NULL) mng_info->ob[i]->frozen=MagickTrue; #endif } if (length != 0) chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0)) { if ((length == 0) || !memcmp(type,mng_SEEK,4)) { for (i=1; i < MNG_MAX_OBJECTS; i++) MngInfoDiscardObject(mng_info,i); } else { register ssize_t j; for (j=1; j < (ssize_t) length; j+=2) { i=p[j-1] << 8 | p[j]; MngInfoDiscardObject(mng_info,i); } } if (length != 0) chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_MOVE,4) == 0) { size_t first_object, last_object; if (length > 3) { first_object=(p[0] << 8) | p[1]; last_object=(p[2] << 8) | p[3]; p+=4; for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++) { <Vul_Start><Vul_End> if (mng_info->exists[i] && !mng_info->frozen[i] && (p-chunk) < (ssize_t) (length-8)) { MngPair new_pair; MngPair old_pair; old_pair.a=mng_info->x_off[i]; old_pair.b=mng_info->y_off[i]; new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]); mng_info->x_off[i]=new_pair.a; mng_info->y_off[i]=new_pair.b; } } } chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_LOOP,4) == 0) { ssize_t loop_iters=1; if (length > 4) { loop_level=chunk[0]; mng_info->loop_active[loop_level]=1; loop_iters=mng_get_long(&chunk[1]); if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" LOOP level %.20g has %.20g iterations \", (double) loop_level, (double) loop_iters); if (loop_iters == 0) skipping_loop=loop_level; else { mng_info->loop_jump[loop_level]=TellBlob(image); mng_info->loop_count[loop_level]=loop_iters; } mng_info->loop_iteration[loop_level]=0; } chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_ENDL,4) == 0) { if (length > 0) { loop_level=chunk[0]; if (skipping_loop > 0) { if (skipping_loop == loop_level) { skipping_loop=(-1); mng_info->loop_active[loop_level]=0; } } else { if (mng_info->loop_active[loop_level] == 1) { mng_info->loop_count[loop_level]--; mng_info->loop_iteration[loop_level]++; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" ENDL: LOOP level %.20g has %.20g remaining iters \", (double) loop_level,(double) mng_info->loop_count[loop_level]); if (mng_info->loop_count[loop_level] != 0) { offset=SeekBlob(image, mng_info->loop_jump[loop_level], SEEK_SET); if (offset < 0) { chunk=(unsigned char *) RelinquishMagickMemory( chunk); ThrowReaderException(CorruptImageError, \"ImproperImageHeader\"); } } else { short last_level; mng_info->loop_active[loop_level]=0; last_level=(-1); for (i=0; i < loop_level; i++) if (mng_info->loop_active[i] == 1) last_level=(short) i; loop_level=last_level; } } } } chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_CLON,4) == 0) { if (mng_info->clon_warning == 0) (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"CLON is not implemented yet\",\"`%s'\", image->filename); mng_info->clon_warning++; } if (memcmp(type,mng_MAGN,4) == 0) { png_uint_16 magn_first, magn_last, magn_mb, magn_ml, magn_mr, magn_mt, magn_mx, magn_my, magn_methx, magn_methy; if (length > 1) magn_first=(p[0] << 8) | p[1]; else magn_first=0; if (length > 3) magn_last=(p[2] << 8) | p[3]; else magn_last=magn_first; #ifndef MNG_OBJECT_BUFFERS if (magn_first || magn_last) if (mng_info->magn_warning == 0) { (void) ThrowMagickException(&image->exception, GetMagickModule(),CoderError, \"MAGN is not implemented yet for nonzero objects\", \"`%s'\",image->filename); mng_info->magn_warning++; } #endif if (length > 4) magn_methx=p[4]; else magn_methx=0; if (length > 6) magn_mx=(p[5] << 8) | p[6]; else magn_mx=1; if (magn_mx == 0) magn_mx=1; if (length > 8) magn_my=(p[7] << 8) | p[8]; else magn_my=magn_mx; if (magn_my == 0) magn_my=1; if (length > 10) magn_ml=(p[9] << 8) | p[10]; else magn_ml=magn_mx; if (magn_ml == 0) magn_ml=1; if (length > 12) magn_mr=(p[11] << 8) | p[12]; else magn_mr=magn_mx; if (magn_mr == 0) magn_mr=1; if (length > 14) magn_mt=(p[13] << 8) | p[14]; else magn_mt=magn_my; if (magn_mt == 0) magn_mt=1; if (length > 16) magn_mb=(p[15] << 8) | p[16]; else magn_mb=magn_my; if (magn_mb == 0) magn_mb=1; if (length > 17) magn_methy=p[17]; else magn_methy=magn_methx; if (magn_methx > 5 || magn_methy > 5) if (mng_info->magn_warning == 0) { (void) ThrowMagickException(&image->exception, GetMagickModule(),CoderError, \"Unknown MAGN method in MNG datastream\",\"`%s'\", image->filename); mng_info->magn_warning++; } #ifdef MNG_OBJECT_BUFFERS #endif if (magn_first == 0 || magn_last == 0) { mng_info->magn_mb=magn_mb; mng_info->magn_ml=magn_ml; mng_info->magn_mr=magn_mr; mng_info->magn_mt=magn_mt; mng_info->magn_mx=magn_mx; mng_info->magn_my=magn_my; mng_info->magn_methx=magn_methx; mng_info->magn_methy=magn_methy; } } if (memcmp(type,mng_PAST,4) == 0) { if (mng_info->past_warning == 0) (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"PAST is not implemented yet\",\"`%s'\", image->filename); mng_info->past_warning++; } if (memcmp(type,mng_SHOW,4) == 0) { if (mng_info->show_warning == 0) (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"SHOW is not implemented yet\",\"`%s'\", image->filename); mng_info->show_warning++; } if (memcmp(type,mng_sBIT,4) == 0) { if (length < 4) mng_info->have_global_sbit=MagickFalse; else { mng_info->global_sbit.gray=p[0]; mng_info->global_sbit.red=p[0]; mng_info->global_sbit.green=p[1]; mng_info->global_sbit.blue=p[2]; mng_info->global_sbit.alpha=p[3]; mng_info->have_global_sbit=MagickTrue; } } if (memcmp(type,mng_pHYs,4) == 0) { if (length > 8) { mng_info->global_x_pixels_per_unit= (size_t) mng_get_long(p); mng_info->global_y_pixels_per_unit= (size_t) mng_get_long(&p[4]); mng_info->global_phys_unit_type=p[8]; mng_info->have_global_phys=MagickTrue; } else mng_info->have_global_phys=MagickFalse; } if (memcmp(type,mng_pHYg,4) == 0) { if (mng_info->phyg_warning == 0) (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename); mng_info->phyg_warning++; } if (memcmp(type,mng_BASI,4) == 0) { skip_to_iend=MagickTrue; if (mng_info->basi_warning == 0) (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"BASI is not implemented yet\",\"`%s'\", image->filename); mng_info->basi_warning++; #ifdef MNG_BASI_SUPPORTED if (length > 11) { basi_width=(size_t) ((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]); basi_height=(size_t) ((p[4] << 24) | (p[5] << 16) | (p[6] << 8) | p[7]); basi_color_type=p[8]; basi_compression_method=p[9]; basi_filter_type=p[10]; basi_interlace_method=p[11]; } if (length > 13) basi_red=(p[12] << 8) & p[13]; else basi_red=0; if (length > 15) basi_green=(p[14] << 8) & p[15]; else basi_green=0; if (length > 17) basi_blue=(p[16] << 8) & p[17]; else basi_blue=0; if (length > 19) basi_alpha=(p[18] << 8) & p[19]; else { if (basi_sample_depth == 16) basi_alpha=65535L; else basi_alpha=255; } if (length > 20) basi_viewable=p[20]; else basi_viewable=0; #endif chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (memcmp(type,mng_IHDR,4) #if defined(JNG_SUPPORTED) && memcmp(type,mng_JHDR,4) #endif ) { if (length != 0) chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]); mng_info->exists[object_id]=MagickTrue; mng_info->viewable[object_id]=MagickTrue; if (mng_info->invisible[object_id]) { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Skipping invisible object\"); skip_to_iend=MagickTrue; chunk=(unsigned char *) RelinquishMagickMemory(chunk); continue; } #if defined(MNG_INSERT_LAYERS) if (length < 8) { chunk=(unsigned char *) RelinquishMagickMemory(chunk); ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); } image_width=(size_t) mng_get_long(p); image_height=(size_t) mng_get_long(&p[4]); #endif chunk=(unsigned char *) RelinquishMagickMemory(chunk); #if defined(MNG_INSERT_LAYERS) if (insert_layers && mng_type && first_mng_object) { if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) || (image_width < mng_info->mng_width) || (mng_info->clip.right < (ssize_t) mng_info->mng_width) || (image_height < mng_info->mng_height) || (mng_info->clip.bottom < (ssize_t) mng_info->mng_height)) { if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL) { AcquireNextImage(image_info,image); if (GetNextImageInList(image) == (Image *) NULL) return(DestroyImageList(image)); image=SyncNextImageInList(image); } mng_info->image=image; if (term_chunk_found) { image->start_loop=MagickTrue; image->iterations=mng_iterations; term_chunk_found=MagickFalse; } else image->start_loop=MagickFalse; image->delay=0; image->columns=mng_info->mng_width; image->rows=mng_info->mng_height; image->page.width=mng_info->mng_width; image->page.height=mng_info->mng_height; image->page.x=0; image->page.y=0; image->background_color=mng_background_color; (void) SetImageBackgroundColor(image); if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Inserted transparent background layer, W=%.20g, H=%.20g\", (double) mng_info->mng_width,(double) mng_info->mng_height); } } if (insert_layers && (mng_info->framing_mode == 3) && (subframe_width) && (subframe_height) && (simplicity == 0 || (simplicity & 0x08))) { if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL) { AcquireNextImage(image_info,image); if (GetNextImageInList(image) == (Image *) NULL) return(DestroyImageList(image)); image=SyncNextImageInList(image); } mng_info->image=image; if (term_chunk_found) { image->start_loop=MagickTrue; image->iterations=mng_iterations; term_chunk_found=MagickFalse; } else image->start_loop=MagickFalse; image->delay=0; image->columns=subframe_width; image->rows=subframe_height; image->page.width=subframe_width; image->page.height=subframe_height; image->page.x=mng_info->clip.left; image->page.y=mng_info->clip.top; image->background_color=mng_background_color; image->matte=MagickFalse; (void) SetImageBackgroundColor(image); if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\", (double) mng_info->clip.left,(double) mng_info->clip.right, (double) mng_info->clip.top,(double) mng_info->clip.bottom); } #endif first_mng_object=MagickFalse; if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL) { AcquireNextImage(image_info,image); if (GetNextImageInList(image) == (Image *) NULL) return(DestroyImageList(image)); image=SyncNextImageInList(image); } mng_info->image=image; status=SetImageProgress(image,LoadImagesTag,TellBlob(image), GetBlobSize(image)); if (status == MagickFalse) break; if (term_chunk_found) { image->start_loop=MagickTrue; term_chunk_found=MagickFalse; } else image->start_loop=MagickFalse; if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3) { image->delay=frame_delay; frame_delay=default_frame_delay; } else image->delay=0; image->page.width=mng_info->mng_width; image->page.height=mng_info->mng_height; image->page.x=mng_info->x_off[object_id]; image->page.y=mng_info->y_off[object_id]; image->iterations=mng_iterations; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1], type[2],type[3]); offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR); if (offset < 0) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); } mng_info->image=image; mng_info->mng_type=mng_type; mng_info->object_id=object_id; if (memcmp(type,mng_IHDR,4) == 0) image=ReadOnePNGImage(mng_info,image_info,exception); #if defined(JNG_SUPPORTED) else image=ReadOneJNGImage(mng_info,image_info,exception); #endif if (image == (Image *) NULL) { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \"exit ReadJNGImage() with error\"); return((Image *) NULL); } if (image->columns == 0 || image->rows == 0) { (void) CloseBlob(image); return(DestroyImageList(image)); } mng_info->image=image; if (mng_type) { MngBox crop_box; if (mng_info->magn_methx || mng_info->magn_methy) { png_uint_32 magnified_height, magnified_width; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Processing MNG MAGN chunk\"); if (mng_info->magn_methx == 1) { magnified_width=mng_info->magn_ml; if (image->columns > 1) magnified_width += mng_info->magn_mr; if (image->columns > 2) magnified_width += (png_uint_32) ((image->columns-2)*(mng_info->magn_mx)); } else { magnified_width=(png_uint_32) image->columns; if (image->columns > 1) magnified_width += mng_info->magn_ml-1; if (image->columns > 2) magnified_width += mng_info->magn_mr-1; if (image->columns > 3) magnified_width += (png_uint_32) ((image->columns-3)*(mng_info->magn_mx-1)); } if (mng_info->magn_methy == 1) { magnified_height=mng_info->magn_mt; if (image->rows > 1) magnified_height += mng_info->magn_mb; if (image->rows > 2) magnified_height += (png_uint_32) ((image->rows-2)*(mng_info->magn_my)); } else { magnified_height=(png_uint_32) image->rows; if (image->rows > 1) magnified_height += mng_info->magn_mt-1; if (image->rows > 2) magnified_height += mng_info->magn_mb-1; if (image->rows > 3) magnified_height += (png_uint_32) ((image->rows-3)*(mng_info->magn_my-1)); } if (magnified_height > image->rows || magnified_width > image->columns) { Image *large_image; int yy; ssize_t m, y; register ssize_t x; register PixelPacket *n, *q; PixelPacket *next, *prev; png_uint_16 magn_methx, magn_methy; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Allocate magnified image\"); AcquireNextImage(image_info,image); if (GetNextImageInList(image) == (Image *) NULL) return(DestroyImageList(image)); large_image=SyncNextImageInList(image); large_image->columns=magnified_width; large_image->rows=magnified_height; magn_methx=mng_info->magn_methx; magn_methy=mng_info->magn_methy; #if (MAGICKCORE_QUANTUM_DEPTH > 16) #define QM unsigned short if (magn_methx != 1 || magn_methy != 1) { for (y=0; y < (ssize_t) image->rows; y++) { q=GetAuthenticPixels(image,0,y,image->columns,1, exception); for (x=(ssize_t) image->columns-1; x >= 0; x--) { SetPixelRed(q,ScaleQuantumToShort( GetPixelRed(q))); SetPixelGreen(q,ScaleQuantumToShort( GetPixelGreen(q))); SetPixelBlue(q,ScaleQuantumToShort( GetPixelBlue(q))); SetPixelOpacity(q,ScaleQuantumToShort( GetPixelOpacity(q))); q++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; } } #else #define QM Quantum #endif if (image->matte != MagickFalse) (void) SetImageBackgroundColor(large_image); else { large_image->background_color.opacity=OpaqueOpacity; (void) SetImageBackgroundColor(large_image); if (magn_methx == 4) magn_methx=2; if (magn_methx == 5) magn_methx=3; if (magn_methy == 4) magn_methy=2; if (magn_methy == 5) magn_methy=3; } if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Magnify the rows to %.20g\",(double) large_image->rows); m=(ssize_t) mng_info->magn_mt; yy=0; length=(size_t) image->columns; next=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*next)); prev=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*prev)); if ((prev == (PixelPacket *) NULL) || (next == (PixelPacket *) NULL)) { image=DestroyImageList(image); ThrowReaderException(ResourceLimitError, \"MemoryAllocationFailed\"); } n=GetAuthenticPixels(image,0,0,image->columns,1,exception); (void) CopyMagickMemory(next,n,length); for (y=0; y < (ssize_t) image->rows; y++) { if (y == 0) m=(ssize_t) mng_info->magn_mt; else if (magn_methy > 1 && y == (ssize_t) image->rows-2) m=(ssize_t) mng_info->magn_mb; else if (magn_methy <= 1 && y == (ssize_t) image->rows-1) m=(ssize_t) mng_info->magn_mb; else if (magn_methy > 1 && y == (ssize_t) image->rows-1) m=1; else m=(ssize_t) mng_info->magn_my; n=prev; prev=next; next=n; if (y < (ssize_t) image->rows-1) { n=GetAuthenticPixels(image,0,y+1,image->columns,1, exception); (void) CopyMagickMemory(next,n,length); } for (i=0; i < m; i++, yy++) { register PixelPacket *pixels; assert(yy < (ssize_t) large_image->rows); pixels=prev; n=next; q=GetAuthenticPixels(large_image,0,yy,large_image->columns, 1,exception); q+=(large_image->columns-image->columns); for (x=(ssize_t) image->columns-1; x >= 0; x--) { if (magn_methy <= 1) { SetPixelRGBO(q,(pixels)); } else if (magn_methy == 2 || magn_methy == 4) { if (i == 0) { SetPixelRGBO(q,(pixels)); } else { SetPixelRed(q, ((QM) (((ssize_t) (2*i*(GetPixelRed(n) -GetPixelRed(pixels)+m))/ ((ssize_t) (m*2)) +GetPixelRed(pixels))))); SetPixelGreen(q, ((QM) (((ssize_t) (2*i*(GetPixelGreen(n) -GetPixelGreen(pixels)+m))/ ((ssize_t) (m*2)) +GetPixelGreen(pixels))))); SetPixelBlue(q, ((QM) (((ssize_t) (2*i*(GetPixelBlue(n) -GetPixelBlue(pixels)+m))/ ((ssize_t) (m*2)) +GetPixelBlue(pixels))))); if (image->matte != MagickFalse) SetPixelOpacity(q, ((QM) (((ssize_t) (2*i*(GetPixelOpacity(n) -GetPixelOpacity(pixels)+m)) /((ssize_t) (m*2))+ GetPixelOpacity(pixels))))); } if (magn_methy == 4) { if (i <= ((m+1) << 1)) SetPixelOpacity(q, (*pixels).opacity+0); else SetPixelOpacity(q, (*n).opacity+0); } } else { if (i <= ((m+1) << 1)) { SetPixelRGBO(q,(pixels)); } else { SetPixelRGBO(q,(n)); } if (magn_methy == 5) { SetPixelOpacity(q, (QM) (((ssize_t) (2*i* (GetPixelOpacity(n) -GetPixelOpacity(pixels)) +m))/((ssize_t) (m*2)) +GetPixelOpacity(pixels))); } } n++; q++; pixels++; } if (SyncAuthenticPixels(large_image,exception) == 0) break; } } prev=(PixelPacket *) RelinquishMagickMemory(prev); next=(PixelPacket *) RelinquishMagickMemory(next); length=image->columns; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Delete original image\"); DeleteImageFromList(&image); image=large_image; mng_info->image=image; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Magnify the columns to %.20g\",(double) image->columns); for (y=0; y < (ssize_t) image->rows; y++) { register PixelPacket *pixels; q=GetAuthenticPixels(image,0,y,image->columns,1,exception); pixels=q+(image->columns-length); n=pixels+1; for (x=(ssize_t) (image->columns-length); x < (ssize_t) image->columns; x++) { if (x == (ssize_t) (image->columns-length)) m=(ssize_t) mng_info->magn_ml; else if (magn_methx > 1 && x == (ssize_t) image->columns-2) m=(ssize_t) mng_info->magn_mr; else if (magn_methx <= 1 && x == (ssize_t) image->columns-1) m=(ssize_t) mng_info->magn_mr; else if (magn_methx > 1 && x == (ssize_t) image->columns-1) m=1; else m=(ssize_t) mng_info->magn_mx; for (i=0; i < m; i++) { if (magn_methx <= 1) { SetPixelRGBO(q,(pixels)); } else if (magn_methx == 2 || magn_methx == 4) { if (i == 0) { SetPixelRGBO(q,(pixels)); } else { SetPixelRed(q, (QM) ((2*i*( GetPixelRed(n) -GetPixelRed(pixels))+m) /((ssize_t) (m*2))+ GetPixelRed(pixels))); SetPixelGreen(q, (QM) ((2*i*( GetPixelGreen(n) -GetPixelGreen(pixels))+m) /((ssize_t) (m*2))+ GetPixelGreen(pixels))); SetPixelBlue(q, (QM) ((2*i*( GetPixelBlue(n) -GetPixelBlue(pixels))+m) /((ssize_t) (m*2))+ GetPixelBlue(pixels))); if (image->matte != MagickFalse) SetPixelOpacity(q, (QM) ((2*i*( GetPixelOpacity(n) -GetPixelOpacity(pixels))+m) /((ssize_t) (m*2))+ GetPixelOpacity(pixels))); } if (magn_methx == 4) { if (i <= ((m+1) << 1)) { SetPixelOpacity(q, GetPixelOpacity(pixels)+0); } else { SetPixelOpacity(q, GetPixelOpacity(n)+0); } } } else { if (i <= ((m+1) << 1)) { SetPixelRGBO(q,(pixels)); } else { SetPixelRGBO(q,(n)); } if (magn_methx == 5) { SetPixelOpacity(q, (QM) ((2*i*( GetPixelOpacity(n) -GetPixelOpacity(pixels))+m)/ ((ssize_t) (m*2)) +GetPixelOpacity(pixels))); } } q++; } n++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; } #if (MAGICKCORE_QUANTUM_DEPTH > 16) if (magn_methx != 1 || magn_methy != 1) { for (y=0; y < (ssize_t) image->rows; y++) { q=GetAuthenticPixels(image,0,y,image->columns,1,exception); for (x=(ssize_t) image->columns-1; x >= 0; x--) { SetPixelRed(q,ScaleShortToQuantum( GetPixelRed(q))); SetPixelGreen(q,ScaleShortToQuantum( GetPixelGreen(q))); SetPixelBlue(q,ScaleShortToQuantum( GetPixelBlue(q))); SetPixelOpacity(q,ScaleShortToQuantum( GetPixelOpacity(q))); q++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; } } #endif if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Finished MAGN processing\"); } } crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id]; crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id]; crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id]; crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id]; crop_box=mng_minimum_box(crop_box,mng_info->clip); crop_box=mng_minimum_box(crop_box,mng_info->frame); crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]); if ((crop_box.left != (mng_info->image_box.left +mng_info->x_off[object_id])) || (crop_box.right != (mng_info->image_box.right +mng_info->x_off[object_id])) || (crop_box.top != (mng_info->image_box.top +mng_info->y_off[object_id])) || (crop_box.bottom != (mng_info->image_box.bottom +mng_info->y_off[object_id]))) { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Crop the PNG image\"); if ((crop_box.left < crop_box.right) && (crop_box.top < crop_box.bottom)) { Image *im; RectangleInfo crop_info; crop_info.x=(crop_box.left-mng_info->x_off[object_id]); crop_info.y=(crop_box.top-mng_info->y_off[object_id]); crop_info.width=(size_t) (crop_box.right-crop_box.left); crop_info.height=(size_t) (crop_box.bottom-crop_box.top); image->page.width=image->columns; image->page.height=image->rows; image->page.x=0; image->page.y=0; im=CropImage(image,&crop_info,exception); if (im != (Image *) NULL) { image->columns=im->columns; image->rows=im->rows; im=DestroyImage(im); image->page.width=image->columns; image->page.height=image->rows; image->page.x=crop_box.left; image->page.y=crop_box.top; } } else { image->columns=1; image->rows=1; image->colors=2; (void) SetImageBackgroundColor(image); image->page.width=1; image->page.height=1; image->page.x=0; image->page.y=0; } } #ifndef PNG_READ_EMPTY_PLTE_SUPPORTED image=mng_info->image; #endif } #if (MAGICKCORE_QUANTUM_DEPTH > 16) if (image->depth > 16) image->depth=16; #endif #if (MAGICKCORE_QUANTUM_DEPTH > 8) if (image->depth > 8) { image->depth=16; } if (LosslessReduceDepthOK(image) != MagickFalse) image->depth = 8; #endif GetImageException(image,exception); if (image_info->number_scenes != 0) { if (mng_info->scenes_found > (ssize_t) (image_info->first_scene+image_info->number_scenes)) break; } if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Finished reading image datastream.\"); } while (LocaleCompare(image_info->magick,\"MNG\") == 0); (void) CloseBlob(image); if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Finished reading all image datastreams.\"); #if defined(MNG_INSERT_LAYERS) if (insert_layers && !mng_info->image_found && (mng_info->mng_width) && (mng_info->mng_height)) { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" No images found. Inserting a background layer.\"); if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL) { AcquireNextImage(image_info,image); if (GetNextImageInList(image) == (Image *) NULL) { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Allocation failed, returning NULL.\"); return(DestroyImageList(image)); } image=SyncNextImageInList(image); } image->columns=mng_info->mng_width; image->rows=mng_info->mng_height; image->page.width=mng_info->mng_width; image->page.height=mng_info->mng_height; image->page.x=0; image->page.y=0; image->background_color=mng_background_color; image->matte=MagickFalse; if (image_info->ping == MagickFalse) (void) SetImageBackgroundColor(image); mng_info->image_found++; } #endif image->iterations=mng_iterations; if (mng_iterations == 1) image->start_loop=MagickTrue; while (GetPreviousImageInList(image) != (Image *) NULL) { image_count++; if (image_count > 10*mng_info->image_found) { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(),\" No beginning\"); (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"Linked list is corrupted, beginning of list not found\", \"`%s'\",image_info->filename); return(DestroyImageList(image)); } image=GetPreviousImageInList(image); if (GetNextImageInList(image) == (Image *) NULL) { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(),\" Corrupt list\"); (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\", image_info->filename); } } if (mng_info->ticks_per_second && mng_info->image_found > 1 && GetNextImageInList(image) == (Image *) NULL) { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" First image null\"); (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"image->next for first image is NULL but shouldn't be.\", \"`%s'\",image_info->filename); } if (mng_info->image_found == 0) { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" No visible images found.\"); (void) ThrowMagickException(&image->exception,GetMagickModule(), CoderError,\"No visible images in file\",\"`%s'\",image_info->filename); return(DestroyImageList(image)); } if (mng_info->ticks_per_second) final_delay=1UL*MagickMax(image->ticks_per_second,1L)* final_delay/mng_info->ticks_per_second; else image->start_loop=MagickTrue; final_image_delay=0; while (GetNextImageInList(image) != (Image *) NULL) { if (image->delay) final_image_delay=image->delay; image=GetNextImageInList(image); } if (final_delay < final_image_delay) final_delay=final_image_delay; image->delay=final_delay; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" image->delay=%.20g, final_delay=%.20g\",(double) image->delay, (double) final_delay); if (logging != MagickFalse) { int scene; scene=0; image=GetFirstImageInList(image); (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" Before coalesce:\"); (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" scene 0 delay=%.20g\",(double) image->delay); while (GetNextImageInList(image) != (Image *) NULL) { image=GetNextImageInList(image); (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" scene %.20g delay=%.20g\",(double) scene++,(double) image->delay); } } image=GetFirstImageInList(image); #ifdef MNG_COALESCE_LAYERS if (insert_layers) { Image *next_image, *next; size_t scene; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(),\" Coalesce Images\"); scene=image->scene; next_image=CoalesceImages(image,&image->exception); if (next_image == (Image *) NULL) ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"); image=DestroyImageList(image); image=next_image; for (next=image; next != (Image *) NULL; next=next_image) { next->page.width=mng_info->mng_width; next->page.height=mng_info->mng_height; next->page.x=0; next->page.y=0; next->scene=scene++; next_image=GetNextImageInList(next); if (next_image == (Image *) NULL) break; if (next->delay == 0) { scene--; next_image->previous=GetPreviousImageInList(next); if (GetPreviousImageInList(next) == (Image *) NULL) image=next_image; else next->previous->next=next_image; next=DestroyImage(next); } } } #endif while (GetNextImageInList(image) != (Image *) NULL) image=GetNextImageInList(image); image->dispose=BackgroundDispose; if (logging != MagickFalse) { int scene; scene=0; image=GetFirstImageInList(image); (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" After coalesce:\"); (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" scene 0 delay=%.20g dispose=%.20g\",(double) image->delay, (double) image->dispose); while (GetNextImageInList(image) != (Image *) NULL) { image=GetNextImageInList(image); (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" scene %.20g delay=%.20g dispose=%.20g\",(double) scene++, (double) image->delay,(double) image->dispose); } } if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" exit ReadOneJNGImage();\"); return(image); } ",
        "vulrepair": "<Vul_Start> if (length > GetBlobSize(image)) ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");<Vul_End>"
    },
    {
        "index": 184647,
        "output": "<Vul_Start> if (MessageLoop::current()!= host_context_.main_message_loop()) { host_context_.main_message_loop()->PostTask(FROM_HERE, base::Bind(&HostNPScriptObject::OnShutdownFinished, base::Unretained(this))); return; }<Vul_End>",
        "label": "<Vul_Start> if (MessageLoop::current()!= host_context_.main_message_loop()) { host_context_.main_message_loop()->PostTask(FROM_HERE, base::Bind( &HostNPScriptObject::OnShutdownFinished, base::Unretained(this))); return; }<Vul_End>",
        "match": true,
        "source": " void HostNPScriptObject::OnShutdownFinished() { <Vul_Start> DCHECK_EQ(MessageLoop::current(), host_context_.main_message_loop()); <Vul_End> disconnected_event_.Signal(); } ",
        "vulrepair": "<Vul_Start> if (MessageLoop::current()!= host_context_.main_message_loop()) { host_context_.main_message_loop()->PostTask(FROM_HERE, base::Bind( &HostNPScriptObject::OnShutdownFinished, base::Unretained(this))); host_context_.main_message_loop()->PostTask(FROM_HERE, base::Unretained(this))); }<Vul_End>"
    },
    {
        "index": 178144,
        "output": "<Vul_Start> <Vul_End><Vul_Start> <Vul_End>",
        "label": "<Vul_Start> <Vul_End><Vul_Start> <Vul_End>",
        "match": true,
        "source": " PHP_METHOD(snmp, __construct) { php_snmp_object *snmp_object; zval *object = getThis(); char *a1, *a2; int a1_len, a2_len; long timeout = SNMP_DEFAULT_TIMEOUT; long retries = SNMP_DEFAULT_RETRIES; long version = SNMP_DEFAULT_VERSION; int argc = ZEND_NUM_ARGS(); zend_error_handling error_handling; snmp_object = (php_snmp_object *)zend_object_store_get_object(object TSRMLS_CC); zend_replace_error_handling(EH_THROW, NULL, &error_handling TSRMLS_CC); <Vul_Start><Vul_End> if (zend_parse_parameters(argc TSRMLS_CC, \"lss|ll\", &version, &a1, &a1_len, &a2, &a2_len, &timeout, &retries) == FAILURE) { zend_restore_error_handling(&error_handling TSRMLS_CC); return; } zend_restore_error_handling(&error_handling TSRMLS_CC); switch(version) { case SNMP_VERSION_1: case SNMP_VERSION_2c: case SNMP_VERSION_3: break; default: zend_throw_exception(zend_exception_get_default(TSRMLS_C), \"Unknown SNMP protocol version\", 0 TSRMLS_CC); return; } if (snmp_object->session) { netsnmp_session_free(&(snmp_object->session)); } <Vul_Start><Vul_End> if (netsnmp_session_init(&(snmp_object->session), version, a1, a2, timeout, retries TSRMLS_CC)) { return; } snmp_object->max_oids = 0; snmp_object->valueretrieval = SNMP_G(valueretrieval); snmp_object->enum_print = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM); snmp_object->oid_output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT); snmp_object->quick_print = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT); snmp_object->oid_increasing_check = TRUE; snmp_object->exceptions_enabled = 0; } ",
        "vulrepair": "<Vul_Start> <Vul_End><Vul_Start> if (snmp_object->session) {<Vul_End>"
    },
    {
        "index": 178547,
        "output": "<Vul_Start> sprintf( word, \"%s\", getJobActionString(mode));<Vul_End>",
        "label": "<Vul_Start> sprintf( word, \"%s\", getJobActionString(mode) );<Vul_End>",
        "match": true,
        "source": " usage(int iExitCode) { char word[32]; <Vul_Start> sprintf( word, getJobActionString(mode) ); <Vul_End> fprintf( stderr, \"Usage: %s [options] [constraints]\\n\", MyName ); fprintf( stderr, \" where [options] is zero or more of:\\n\" ); fprintf( stderr, \" -help Display this message and exit\\n\" ); fprintf( stderr, \" -version Display version information and exit\\n\" ); fprintf( stderr, \" -name schedd_name Connect to the given schedd\\n\" ); fprintf( stderr, \" -pool hostname Use the given central manager to find daemons\\n\" ); fprintf( stderr, \" -addr <ip:port> Connect directly to the given \\\"sinful string\\\"\\n\" ); if( mode == JA_REMOVE_JOBS || mode == JA_REMOVE_X_JOBS ) { fprintf( stderr, \" -reason reason Use the given RemoveReason\\n\"); } else if( mode == JA_RELEASE_JOBS ) { fprintf( stderr, \" -reason reason Use the given ReleaseReason\\n\"); } else if( mode == JA_HOLD_JOBS ) { fprintf( stderr, \" -reason reason Use the given HoldReason\\n\"); fprintf( stderr, \" -subcode number Set HoldReasonSubCode\\n\"); } if( mode == JA_REMOVE_JOBS || mode == JA_REMOVE_X_JOBS ) { fprintf( stderr, \" -forcex Force the immediate local removal of jobs in the X state\\n\" \" (only affects jobs already being removed)\\n\" ); } if( mode == JA_VACATE_JOBS || mode == JA_VACATE_FAST_JOBS ) { fprintf( stderr, \" -fast Use a fast vacate (hardkill)\\n\" ); } fprintf( stderr, \" and where [constraints] is one of:\\n\" ); fprintf( stderr, \" cluster.proc %s the given job\\n\", word ); fprintf( stderr, \" cluster %s the given cluster of jobs\\n\", word ); fprintf( stderr, \" user %s all jobs owned by user\\n\", word ); fprintf( stderr, \" -constraint expr %s all jobs matching the boolean expression\\n\", word ); fprintf( stderr, \" -all %s all jobs \" \"(cannot be used with other constraints)\\n\", word ); exit( iExitCode ); } ",
        "vulrepair": "<Vul_Start> sprintf( word, \"%s %s\", getJobActionString(mode), getJobActionString(mode) );<Vul_End>"
    },
    {
        "index": 180552,
        "output": "<Vul_Start> buffer = zend_string_safe_alloc(1, len, 0, 0);<Vul_End>",
        "label": "<Vul_Start> buffer = zend_string_safe_alloc(1, len, 0, 0);<Vul_End>",
        "match": true,
        "source": " static PHP_NAMED_FUNCTION(zif_zip_entry_read) { zval * zip_entry; zend_long len = 0; zip_read_rsrc * zr_rsrc; zend_string *buffer; int n = 0; if (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) { return; } if ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) { RETURN_FALSE; } if (len <= 0) { len = 1024; } if (zr_rsrc->zf) { <Vul_Start> buffer = zend_string_alloc(len, 0); <Vul_End> n = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer)); if (n > 0) { ZSTR_VAL(buffer)[n] = '\\0'; ZSTR_LEN(buffer) = n; RETURN_NEW_STR(buffer); } else { zend_string_free(buffer); RETURN_EMPTY_STRING() } } else { RETURN_FALSE; } } ",
        "vulrepair": "<Vul_Start> buffer = zend_string_safe_alloc(len, 0, 0, NULL);<Vul_End>"
    },
    {
        "index": 183402,
        "output": "<Vul_Start> if (!pipe_buf_get(ipipe, ibuf)) { if (ret == 0) ret = -EFAULT; break; }<Vul_End>",
        "label": "<Vul_Start> if (!pipe_buf_get(ipipe, ibuf)) { if (ret == 0) ret = -EFAULT; break; }<Vul_End>",
        "match": true,
        "source": " static int link_pipe(struct pipe_inode_info *ipipe, struct pipe_inode_info *opipe, size_t len, unsigned int flags) { struct pipe_buffer *ibuf, *obuf; int ret = 0, i = 0, nbuf; pipe_double_lock(ipipe, opipe); do { if (!opipe->readers) { send_sig(SIGPIPE, current, 0); if (!ret) ret = -EPIPE; break; } if (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) break; ibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1)); nbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1); <Vul_Start> pipe_buf_get(ipipe, ibuf); <Vul_End> obuf = opipe->bufs + nbuf; *obuf = *ibuf; obuf->flags &= ~PIPE_BUF_FLAG_GIFT; if (obuf->len > len) obuf->len = len; opipe->nrbufs++; ret += obuf->len; len -= obuf->len; i++; } while (len); if (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK)) ret = -EAGAIN; pipe_unlock(ipipe); pipe_unlock(opipe); if (ret > 0) wakeup_pipe_readers(opipe); return ret; } ",
        "vulrepair": "<Vul_Start> if (!pipe_buf_get(ipipe, ibuf)) break;<Vul_End>"
    },
    {
        "index": 178673,
        "output": "<Vul_Start> uint32_t n_dicts = jbig2_sd_count_referred(ctx, segment);<Vul_End><Vul_Start> uint32_t dindex = 0;<Vul_End>",
        "label": "<Vul_Start> uint32_t n_dicts = jbig2_sd_count_referred(ctx, segment);<Vul_End><Vul_Start> uint32_t dindex = 0;<Vul_End>",
        "match": true,
        "source": " jbig2_sd_list_referred(Jbig2Ctx *ctx, Jbig2Segment *segment) { int index; Jbig2Segment *rsegment; Jbig2SymbolDict **dicts; <Vul_Start> int n_dicts = jbig2_sd_count_referred(ctx, segment); <Vul_End> <Vul_Start> int dindex = 0; <Vul_End> dicts = jbig2_new(ctx, Jbig2SymbolDict *, n_dicts); if (dicts == NULL) { jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate referred list of symbol dictionaries\"); return NULL; } for (index = 0; index < segment->referred_to_segment_count; index++) { rsegment = jbig2_find_segment(ctx, segment->referred_to_segments[index]); if (rsegment && ((rsegment->flags & 63) == 0) && rsegment->result && (((Jbig2SymbolDict *) rsegment->result)->n_symbols > 0) && ((*((Jbig2SymbolDict *) rsegment->result)->glyphs) != NULL)) { dicts[dindex++] = (Jbig2SymbolDict *) rsegment->result; } } if (dindex != n_dicts) { jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"counted %d symbol dictionaries but built a list with %d.\\n\", n_dicts, dindex); } return (dicts); } ",
        "vulrepair": "<Vul_Start> uint32_t n_dicts = jbig2_sd_count_referred(ctx, segment->number);<Vul_End><Vul_Start> uint32_t dindex = 0;<Vul_End>"
    },
    {
        "index": 181135,
        "output": "<Vul_Start> if (SyncImagePixelCache(image,exception) == MagickFalse) return(MagickFalse);<Vul_End>",
        "label": "<Vul_Start> if (SyncImagePixelCache(image,exception) == MagickFalse) return(MagickFalse);<Vul_End>",
        "match": true,
        "source": " MagickExport MagickBooleanType ContrastStretchImage(Image *image, const double black_point,const double white_point,ExceptionInfo *exception) { #define MaxRange(color) ((double) ScaleQuantumToMap((Quantum) (color))) #define ContrastStretchImageTag \"ContrastStretch/Image\" CacheView *image_view; double *black, *histogram, *stretch_map, *white; MagickBooleanType status; MagickOffsetType progress; register ssize_t i; ssize_t y; assert(image != (Image *) NULL); assert(image->signature == MagickCoreSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); <Vul_Start><Vul_End> if (SetImageGray(image,exception) != MagickFalse) (void) SetImageColorspace(image,GRAYColorspace,exception); black=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*black)); white=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*white)); histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)* sizeof(*histogram)); stretch_map=(double *) AcquireQuantumMemory(MaxMap+1UL, GetPixelChannels(image)*sizeof(*stretch_map)); if ((black == (double *) NULL) || (white == (double *) NULL) || (histogram == (double *) NULL) || (stretch_map == (double *) NULL)) { if (stretch_map != (double *) NULL) stretch_map=(double *) RelinquishMagickMemory(stretch_map); if (histogram != (double *) NULL) histogram=(double *) RelinquishMagickMemory(histogram); if (white != (double *) NULL) white=(double *) RelinquishMagickMemory(white); if (black != (double *) NULL) black=(double *) RelinquishMagickMemory(black); ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\", image->filename); } status=MagickTrue; (void) ResetMagickMemory(histogram,0,(MaxMap+1)*GetPixelChannels(image)* sizeof(*histogram)); image_view=AcquireVirtualCacheView(image,exception); for (y=0; y < (ssize_t) image->rows; y++) { register const Quantum *magick_restrict p; register ssize_t x; if (status == MagickFalse) continue; p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); if (p == (const Quantum *) NULL) { status=MagickFalse; continue; } for (x=0; x < (ssize_t) image->columns; x++) { double pixel; pixel=GetPixelIntensity(image,p); for (i=0; i < (ssize_t) GetPixelChannels(image); i++) { if (image->channel_mask != DefaultChannels) pixel=(double) p[i]; histogram[GetPixelChannels(image)*ScaleQuantumToMap( ClampToQuantum(pixel))+i]++; } p+=GetPixelChannels(image); } } image_view=DestroyCacheView(image_view); for (i=0; i < (ssize_t) GetPixelChannels(image); i++) { double intensity; register ssize_t j; black[i]=0.0; white[i]=MaxRange(QuantumRange); intensity=0.0; for (j=0; j <= (ssize_t) MaxMap; j++) { intensity+=histogram[GetPixelChannels(image)*j+i]; if (intensity > black_point) break; } black[i]=(double) j; intensity=0.0; for (j=(ssize_t) MaxMap; j != 0; j--) { intensity+=histogram[GetPixelChannels(image)*j+i]; if (intensity > ((double) image->columns*image->rows-white_point)) break; } white[i]=(double) j; } histogram=(double *) RelinquishMagickMemory(histogram); (void) ResetMagickMemory(stretch_map,0,(MaxMap+1)*GetPixelChannels(image)* sizeof(*stretch_map)); for (i=0; i < (ssize_t) GetPixelChannels(image); i++) { register ssize_t j; for (j=0; j <= (ssize_t) MaxMap; j++) { double gamma; gamma=PerceptibleReciprocal(white[i]-black[i]); if (j < (ssize_t) black[i]) stretch_map[GetPixelChannels(image)*j+i]=0.0; else if (j > (ssize_t) white[i]) stretch_map[GetPixelChannels(image)*j+i]=(double) QuantumRange; else if (black[i] != white[i]) stretch_map[GetPixelChannels(image)*j+i]=(double) ScaleMapToQuantum( (double) (MaxMap*gamma*(j-black[i]))); } } if (image->storage_class == PseudoClass) { register ssize_t j; for (j=0; j < (ssize_t) image->colors; j++) { if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0) { i=GetPixelChannelOffset(image,RedPixelChannel); image->colormap[j].red=stretch_map[GetPixelChannels(image)* ScaleQuantumToMap(ClampToQuantum(image->colormap[j].red))+i]; } if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0) { i=GetPixelChannelOffset(image,GreenPixelChannel); image->colormap[j].green=stretch_map[GetPixelChannels(image)* ScaleQuantumToMap(ClampToQuantum(image->colormap[j].green))+i]; } if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0) { i=GetPixelChannelOffset(image,BluePixelChannel); image->colormap[j].blue=stretch_map[GetPixelChannels(image)* ScaleQuantumToMap(ClampToQuantum(image->colormap[j].blue))+i]; } if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) { i=GetPixelChannelOffset(image,AlphaPixelChannel); image->colormap[j].alpha=stretch_map[GetPixelChannels(image)* ScaleQuantumToMap(ClampToQuantum(image->colormap[j].alpha))+i]; } } } status=MagickTrue; progress=0; image_view=AcquireAuthenticCacheView(image,exception); #if defined(MAGICKCORE_OPENMP_SUPPORT) #pragma omp parallel for schedule(static,4) shared(progress,status) \\ magick_threads(image,image,image->rows,1) #endif for (y=0; y < (ssize_t) image->rows; y++) { register Quantum *magick_restrict q; register ssize_t x; if (status == MagickFalse) continue; q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) { status=MagickFalse; continue; } for (x=0; x < (ssize_t) image->columns; x++) { register ssize_t j; if (GetPixelWriteMask(image,q) == 0) { q+=GetPixelChannels(image); continue; } for (j=0; j < (ssize_t) GetPixelChannels(image); j++) { PixelChannel channel=GetPixelChannelChannel(image,j); PixelTrait traits=GetPixelChannelTraits(image,channel); if ((traits & UpdatePixelTrait) == 0) continue; if (black[j] == white[j]) continue; q[j]=ClampToQuantum(stretch_map[GetPixelChannels(image)* ScaleQuantumToMap(q[j])+j]); } q+=GetPixelChannels(image); } if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse) status=MagickFalse; if (image->progress_monitor != (MagickProgressMonitor) NULL) { MagickBooleanType proceed; #if defined(MAGICKCORE_OPENMP_SUPPORT) #pragma omp critical (MagickCore_ContrastStretchImage) #endif proceed=SetImageProgress(image,ContrastStretchImageTag,progress++, image->rows); if (proceed == MagickFalse) status=MagickFalse; } } image_view=DestroyCacheView(image_view); stretch_map=(double *) RelinquishMagickMemory(stretch_map); white=(double *) RelinquishMagickMemory(white); black=(double *) RelinquishMagickMemory(black); return(status); } ",
        "vulrepair": "<Vul_Start> if (SyncImagePixelCache(image,exception) == MagickFalse) ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",image->filename);<Vul_End>"
    },
    {
        "index": 186115,
        "output": "<Vul_Start> : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {<Vul_End>",
        "label": "<Vul_Start> : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {<Vul_End>",
        "match": true,
        "source": " RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context) <Vul_Start> : ObjectBackedNativeHandler(context) { <Vul_End> RouteFunction( \"OnDocumentElementCreated\", base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated, base::Unretained(this))); } ",
        "vulrepair": "<Vul_Start> : ObjectBackedNativeHandler(context) {<Vul_End>"
    },
    {
        "index": 186788,
        "output": "<Vul_Start> DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);<Vul_End>",
        "label": "<Vul_Start> DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);<Vul_End>",
        "match": true,
        "source": " bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::SubmitFrameMetadata( const H264SPS* sps, const H264PPS* pps, const H264DPB& dpb, const H264Picture::Vector& ref_pic_listp0, const H264Picture::Vector& ref_pic_listb0, const H264Picture::Vector& ref_pic_listb1, const scoped_refptr<H264Picture>& pic) { <Vul_Start><Vul_End> VAPictureParameterBufferH264 pic_param; memset(&pic_param, 0, sizeof(pic_param)); #define FROM_SPS_TO_PP(a) pic_param.a = sps->a #define FROM_SPS_TO_PP2(a, b) pic_param.b = sps->a FROM_SPS_TO_PP2(pic_width_in_mbs_minus1, picture_width_in_mbs_minus1); FROM_SPS_TO_PP2(pic_height_in_map_units_minus1, picture_height_in_mbs_minus1); FROM_SPS_TO_PP(bit_depth_luma_minus8); FROM_SPS_TO_PP(bit_depth_chroma_minus8); #undef FROM_SPS_TO_PP #undef FROM_SPS_TO_PP2 #define FROM_SPS_TO_PP_SF(a) pic_param.seq_fields.bits.a = sps->a #define FROM_SPS_TO_PP_SF2(a, b) pic_param.seq_fields.bits.b = sps->a FROM_SPS_TO_PP_SF(chroma_format_idc); FROM_SPS_TO_PP_SF2(separate_colour_plane_flag, residual_colour_transform_flag); FROM_SPS_TO_PP_SF(gaps_in_frame_num_value_allowed_flag); FROM_SPS_TO_PP_SF(frame_mbs_only_flag); FROM_SPS_TO_PP_SF(mb_adaptive_frame_field_flag); FROM_SPS_TO_PP_SF(direct_8x8_inference_flag); pic_param.seq_fields.bits.MinLumaBiPredSize8x8 = (sps->level_idc >= 31); FROM_SPS_TO_PP_SF(log2_max_frame_num_minus4); FROM_SPS_TO_PP_SF(pic_order_cnt_type); FROM_SPS_TO_PP_SF(log2_max_pic_order_cnt_lsb_minus4); FROM_SPS_TO_PP_SF(delta_pic_order_always_zero_flag); #undef FROM_SPS_TO_PP_SF #undef FROM_SPS_TO_PP_SF2 #define FROM_PPS_TO_PP(a) pic_param.a = pps->a FROM_PPS_TO_PP(pic_init_qp_minus26); FROM_PPS_TO_PP(pic_init_qs_minus26); FROM_PPS_TO_PP(chroma_qp_index_offset); FROM_PPS_TO_PP(second_chroma_qp_index_offset); #undef FROM_PPS_TO_PP #define FROM_PPS_TO_PP_PF(a) pic_param.pic_fields.bits.a = pps->a #define FROM_PPS_TO_PP_PF2(a, b) pic_param.pic_fields.bits.b = pps->a FROM_PPS_TO_PP_PF(entropy_coding_mode_flag); FROM_PPS_TO_PP_PF(weighted_pred_flag); FROM_PPS_TO_PP_PF(weighted_bipred_idc); FROM_PPS_TO_PP_PF(transform_8x8_mode_flag); pic_param.pic_fields.bits.field_pic_flag = 0; FROM_PPS_TO_PP_PF(constrained_intra_pred_flag); FROM_PPS_TO_PP_PF2(bottom_field_pic_order_in_frame_present_flag, pic_order_present_flag); FROM_PPS_TO_PP_PF(deblocking_filter_control_present_flag); FROM_PPS_TO_PP_PF(redundant_pic_cnt_present_flag); pic_param.pic_fields.bits.reference_pic_flag = pic->ref; #undef FROM_PPS_TO_PP_PF #undef FROM_PPS_TO_PP_PF2 pic_param.frame_num = pic->frame_num; InitVAPicture(&pic_param.CurrPic); FillVAPicture(&pic_param.CurrPic, pic); for (int i = 0; i < 16; ++i) InitVAPicture(&pic_param.ReferenceFrames[i]); FillVARefFramesFromDPB(dpb, pic_param.ReferenceFrames, arraysize(pic_param.ReferenceFrames)); pic_param.num_ref_frames = sps->max_num_ref_frames; if (!vaapi_wrapper_->SubmitBuffer(VAPictureParameterBufferType, sizeof(pic_param), &pic_param)) return false; VAIQMatrixBufferH264 iq_matrix_buf; memset(&iq_matrix_buf, 0, sizeof(iq_matrix_buf)); if (pps->pic_scaling_matrix_present_flag) { for (int i = 0; i < 6; ++i) { for (int j = 0; j < 16; ++j) iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] = pps->scaling_list4x4[i][j]; } for (int i = 0; i < 2; ++i) { for (int j = 0; j < 64; ++j) iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] = pps->scaling_list8x8[i][j]; } } else { for (int i = 0; i < 6; ++i) { for (int j = 0; j < 16; ++j) iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] = sps->scaling_list4x4[i][j]; } for (int i = 0; i < 2; ++i) { for (int j = 0; j < 64; ++j) iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] = sps->scaling_list8x8[i][j]; } } return vaapi_wrapper_->SubmitBuffer(VAIQMatrixBufferType, sizeof(iq_matrix_buf), &iq_matrix_buf); } ",
        "vulrepair": "<Vul_Start> DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_fields.bits.a)<Vul_End><Vul_Start> DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_fields.bits.a)<Vul_End><Vul_Start> DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_fields.bits.b)<Vul_End><Vul_Start> DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_fields.bits.a)<Vul_End><Vul_Start> CHECK_CALLED_ON_VALID_SEQUENCE(sequence_fields.bits.a)<Vul_End><Vul_Start> CHECK_CALLED_ON_VALID_SEQUENCE(sequence_fields.bits.a)<Vul_End><Vul_Start> CHECK_CALLED_ON_VALID_SEQUENCE(sequence_fields.bits.b)<Vul_End><Vul_Start> CHECK_CALLED_ON_VALID_SEQUENCE(sequence_fields.bits.a)<Vul_End><Vul_Start> CHECK_CALLED_ON_VALID_SEQUENCE(sequence_fields.bits.b)<Vul_End><Vul_Start> CHECK_CALLED_ON_VALID_SEQUENCE(sequence_fields.bits.a)<Vul_End><Vul_Start> CHECK_CALLED_ON_"
    },
    {
        "index": 184187,
        "output": "<Vul_Start> InfoBarView::Layout();<Vul_End>",
        "label": "<Vul_Start> InfoBarView::Layout();<Vul_End>",
        "match": true,
        "source": " void SaveCCInfoConfirmInfoBar::Layout() { <Vul_Start> InfoBar::Layout(); <Vul_End> int available_width = AlertInfoBar::GetAvailableWidth(); link_->SetVisible(!link_->GetText().empty()); gfx::Size link_ps = link_->GetPreferredSize(); int link_x = available_width - kButtonButtonSpacing - link_ps.width(); link_->SetBounds(link_x, OffsetY(this, link_ps), link_ps.width(), link_ps.height()); available_width = link_x; gfx::Size save_ps = save_button_->GetPreferredSize(); gfx::Size dont_save_ps = dont_save_button_->GetPreferredSize(); AlertInfoBar::Layout(); int save_x = label()->bounds().right() + kEndOfLabelSpacing; save_x = std::max(0, std::min(save_x, available_width - (save_ps.width() + dont_save_ps.width() + kButtonButtonSpacing))); save_button_->SetVisible(true); dont_save_button_->SetVisible(true); save_button_->SetBounds(save_x, OffsetY(this, save_ps), save_ps.width(), save_ps.height()); int dont_save_x = save_x + save_ps.width() + kButtonButtonSpacing; dont_save_button_->SetBounds(dont_save_x, OffsetY(this, dont_save_ps), dont_save_ps.width(), dont_save_ps.height()); } ",
        "vulrepair": "<Vul_Start><Vul_End>"
    },
    {
        "index": 186655,
        "output": "<Vul_Start> if (unpack_flip_y_ || unpack_premultiply_alpha_) { SynthesizeGLError( GL_INVALID_OPERATION, \"texSubImage2D\", \"FLIP_Y or PREMULTIPLY_ALPHA isn't allowed while uploading from PBO\"); return; }<Vul_End>",
        "label": "<Vul_Start> if (unpack_flip_y_ || unpack_premultiply_alpha_) { SynthesizeGLError( GL_INVALID_OPERATION, \"texSubImage2D\", \"FLIP_Y or PREMULTIPLY_ALPHA isn't allowed while uploading from PBO\"); return; }<Vul_End>",
        "match": true,
        "source": " void WebGL2RenderingContextBase::texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr offset) { if (isContextLost()) return; if (!ValidateTexture2DBinding(\"texSubImage2D\", target)) return; if (!bound_pixel_unpack_buffer_) { SynthesizeGLError(GL_INVALID_OPERATION, \"texSubImage2D\", \"no bound PIXEL_UNPACK_BUFFER\"); return; } <Vul_Start><Vul_End> if (!ValidateTexFunc(\"texSubImage2D\", kTexSubImage, kSourceUnpackBuffer, target, level, 0, width, height, 1, 0, format, type, xoffset, yoffset, 0)) return; if (!ValidateValueFitNonNegInt32(\"texSubImage2D\", \"offset\", offset)) return; ContextGL()->TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, reinterpret_cast<const void*>(offset)); } ",
        "vulrepair": "<Vul_Start> if (unpack_flip_y_ || unpack_premultiply_alpha_) { SynthesizeGLError( GL_INVALID_OPERATION, \"texSubImage2D\", \"FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 2D textures\"); return; } <Vul_End>"
    },
    {
        "index": 186295,
        "output": "<Vul_Start> interstitial_page_->FocusThroughTabTraversal(reverse);<Vul_End>",
        "label": "<Vul_Start> interstitial_page_->FocusThroughTabTraversal(reverse);<Vul_End>",
        "match": true,
        "source": " void WebContentsImpl::FocusThroughTabTraversal(bool reverse) { if (ShowingInterstitialPage()) { <Vul_Start> GetRenderManager()->interstitial_page()->FocusThroughTabTraversal(reverse); <Vul_End> return; } RenderWidgetHostView* const fullscreen_view = GetFullscreenRenderWidgetHostView(); if (fullscreen_view) { fullscreen_view->Focus(); return; } GetRenderViewHost()->SetInitialFocus(reverse); } ",
        "vulrepair": "<Vul_Start> interstitial_page_->FocusThroughTabTraversal(reverse, GetRenderManager()->interstitial_page_id());<Vul_End>"
    },
    {
        "index": 179169,
        "output": "<Vul_Start> for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)<Vul_End><Vul_Start> for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)<Vul_End>",
        "label": "<Vul_Start> for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)<Vul_End><Vul_Start> for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)<Vul_End>",
        "match": true,
        "source": " static int filter_frame(AVFilterLink *inlink, AVFrame *in) { AVFilterContext *ctx = inlink->dst; BoxBlurContext *s = ctx->priv; AVFilterLink *outlink = inlink->dst->outputs[0]; AVFrame *out; int plane; int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub), ch = FF_CEIL_RSHIFT(in->height, s->vsub); int w[4] = { inlink->w, cw, cw, inlink->w }; int h[4] = { in->height, ch, ch, in->height }; out = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) { av_frame_free(&in); return AVERROR(ENOMEM); } av_frame_copy_props(out, in); <Vul_Start> for (plane = 0; in->data[plane] && plane < 4; plane++) <Vul_End> hblur(out->data[plane], out->linesize[plane], in ->data[plane], in ->linesize[plane], w[plane], h[plane], s->radius[plane], s->power[plane], s->temp); <Vul_Start> for (plane = 0; in->data[plane] && plane < 4; plane++) <Vul_End> vblur(out->data[plane], out->linesize[plane], out->data[plane], out->linesize[plane], w[plane], h[plane], s->radius[plane], s->power[plane], s->temp); av_frame_free(&in); return ff_filter_frame(outlink, out); } ",
        "vulrepair": "<Vul_Start> for (plane = 0; in->data[plane] && plane < 4; plane++)<Vul_End><Vul_Start> for (plane = 0; in->data[plane] && plane < 4; plane++)<Vul_End>"
    },
    {
        "index": 179213,
        "output": "<Vul_Start> msg->msg_namelen = 0;<Vul_End>",
        "label": "<Vul_Start> msg->msg_namelen = 0;<Vul_End>",
        "match": true,
        "source": " static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len, int flags) { struct sock *sk = sock->sk; struct sco_pinfo *pi = sco_pi(sk); lock_sock(sk); if (sk->sk_state == BT_CONNECT2 && test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) { hci_conn_accept(pi->conn->hcon, 0); sk->sk_state = BT_CONFIG; <Vul_Start><Vul_End> release_sock(sk); return 0; } release_sock(sk); return bt_sock_recvmsg(iocb, sock, msg, len, flags); } ",
        "vulrepair": "<Vul_Start> sk->sk_state_change(sk);<Vul_End>"
    },
    {
        "index": 187934,
        "output": "<Vul_Start> const sp<IMediaPlayerService> MediaMetadataRetriever::getService()<Vul_End>",
        "label": "<Vul_Start> const sp<IMediaPlayerService> MediaMetadataRetriever::getService()<Vul_End>",
        "match": true,
        "source": " const sp<IMediaPlayerService>& MediaMetadataRetriever::getService() <Vul_Start><Vul_End> { Mutex::Autolock lock(sServiceLock); if (sService == 0) { sp<IServiceManager> sm = defaultServiceManager(); sp<IBinder> binder; do { binder = sm->getService(String16(\"media.player\")); if (binder != 0) { break; } ALOGW(\"MediaPlayerService not published, waiting...\"); usleep(500000); } while (true); if (sDeathNotifier == NULL) { sDeathNotifier = new DeathNotifier(); } binder->linkToDeath(sDeathNotifier); sService = interface_cast<IMediaPlayerService>(binder); } ALOGE_IF(sService == 0, \"no MediaPlayerService!?\"); return sService; } ",
        "vulrepair": "<Vul_Start> MediaMetadataRetriever::getService()<Vul_End>"
    },
    {
        "index": 181765,
        "output": "<Vul_Start> status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); }<Vul_End>",
        "label": "<Vul_Start> status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); }<Vul_End>",
        "match": true,
        "source": " static Image *ReadPICTImage(const ImageInfo *image_info, ExceptionInfo *exception) { char geometry[MaxTextExtent], header_ole[4]; Image *image; IndexPacket index; int c, code; MagickBooleanType jpeg, status; PICTRectangle frame; PICTPixmap pixmap; register IndexPacket *indexes; register ssize_t x; register PixelPacket *q; register ssize_t i; size_t extent, length; ssize_t count, flags, j, version, y; StringInfo *profile; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } pixmap.bits_per_pixel=0; pixmap.component_count=0; header_ole[0]=ReadBlobByte(image); header_ole[1]=ReadBlobByte(image); header_ole[2]=ReadBlobByte(image); header_ole[3]=ReadBlobByte(image); if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) && (header_ole[2] == 0x43) && (header_ole[3] == 0x54))) for (i=0; i < 508; i++) (void) ReadBlobByte(image); (void) ReadBlobMSBShort(image); if (ReadRectangle(image,&frame) == MagickFalse) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); while ((c=ReadBlobByte(image)) == 0) ; if (c != 0x11) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); version=ReadBlobByte(image); if (version == 2) { c=ReadBlobByte(image); if (c != 0xff) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); } else if (version != 1) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) || (frame.bottom < 0) || (frame.left >= frame.right) || (frame.top >= frame.bottom)) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); flags=0; image->depth=8; image->columns=1UL*(frame.right-frame.left); image->rows=1UL*(frame.bottom-frame.top); image->x_resolution=DefaultResolution; image->y_resolution=DefaultResolution; image->units=UndefinedResolution; jpeg=MagickFalse; for (code=0; EOFBlob(image) == MagickFalse; ) { if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0)) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; <Vul_Start><Vul_End> if ((version == 1) || ((TellBlob(image) % 2) != 0)) code=ReadBlobByte(image); if (version == 2) code=(int) ReadBlobMSBShort(image); if (code < 0) break; if (code > 0xa1) { if (image->debug != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code); } else { if (image->debug != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), \" %04X %s: %s\",code,codes[code].name,codes[code].description); switch (code) { case 0x01: { length=ReadBlobMSBShort(image); if (length != 0x000a) { for (i=0; i < (ssize_t) (length-2); i++) (void) ReadBlobByte(image); break; } if (ReadRectangle(image,&frame) == MagickFalse) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0)) break; image->columns=1UL*(frame.right-frame.left); image->rows=1UL*(frame.bottom-frame.top); (void) SetImageBackgroundColor(image); break; } case 0x12: case 0x13: case 0x14: { ssize_t pattern; size_t height, width; pattern=1L*ReadBlobMSBShort(image); for (i=0; i < 8; i++) (void) ReadBlobByte(image); if (pattern == 2) { for (i=0; i < 5; i++) (void) ReadBlobByte(image); break; } if (pattern != 1) ThrowReaderException(CorruptImageError,\"UnknownPatternType\"); length=ReadBlobMSBShort(image); if (ReadRectangle(image,&frame) == MagickFalse) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); ReadPixmap(pixmap); image->depth=1UL*pixmap.component_size; image->x_resolution=1.0*pixmap.horizontal_resolution; image->y_resolution=1.0*pixmap.vertical_resolution; image->units=PixelsPerInchResolution; (void) ReadBlobMSBLong(image); flags=1L*ReadBlobMSBShort(image); length=ReadBlobMSBShort(image); for (i=0; i <= (ssize_t) length; i++) (void) ReadBlobMSBLong(image); width=1UL*(frame.bottom-frame.top); height=1UL*(frame.right-frame.left); if (pixmap.bits_per_pixel <= 8) length&=0x7fff; if (pixmap.bits_per_pixel == 16) width<<=1; if (length == 0) length=width; if (length < 8) { for (i=0; i < (ssize_t) (length*height); i++) (void) ReadBlobByte(image); } else for (j=0; j < (int) height; j++) if (length > 200) for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++) (void) ReadBlobByte(image); else for (j=0; j < (ssize_t) ReadBlobByte(image); j++) (void) ReadBlobByte(image); break; } case 0x1b: { image->background_color.red=(Quantum) ScaleShortToQuantum(ReadBlobMSBShort(image)); image->background_color.green=(Quantum) ScaleShortToQuantum(ReadBlobMSBShort(image)); image->background_color.blue=(Quantum) ScaleShortToQuantum(ReadBlobMSBShort(image)); break; } case 0x70: case 0x71: case 0x72: case 0x73: case 0x74: case 0x75: case 0x76: case 0x77: { length=ReadBlobMSBShort(image); for (i=0; i < (ssize_t) (length-2); i++) (void) ReadBlobByte(image); break; } case 0x90: case 0x91: case 0x98: case 0x99: case 0x9a: case 0x9b: { ssize_t bytes_per_line; PICTRectangle source, destination; register unsigned char *p; size_t j; unsigned char *pixels; Image *tile_image; bytes_per_line=0; if ((code != 0x9a) && (code != 0x9b)) bytes_per_line=1L*ReadBlobMSBShort(image); else { (void) ReadBlobMSBShort(image); (void) ReadBlobMSBShort(image); (void) ReadBlobMSBShort(image); } if (ReadRectangle(image,&frame) == MagickFalse) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); tile_image=CloneImage(image,1UL*(frame.right-frame.left), 1UL*(frame.bottom-frame.top),MagickTrue,exception); if (tile_image == (Image *) NULL) return((Image *) NULL); if ((code == 0x9a) || (code == 0x9b) || ((bytes_per_line & 0x8000) != 0)) { ReadPixmap(pixmap); tile_image->depth=1UL*pixmap.component_size; tile_image->matte=pixmap.component_count == 4 ? MagickTrue : MagickFalse; tile_image->x_resolution=(double) pixmap.horizontal_resolution; tile_image->y_resolution=(double) pixmap.vertical_resolution; tile_image->units=PixelsPerInchResolution; if (tile_image->matte != MagickFalse) image->matte=tile_image->matte; } if ((code != 0x9a) && (code != 0x9b)) { tile_image->colors=2; if ((bytes_per_line & 0x8000) != 0) { (void) ReadBlobMSBLong(image); flags=1L*ReadBlobMSBShort(image); tile_image->colors=1UL*ReadBlobMSBShort(image)+1; } status=AcquireImageColormap(tile_image,tile_image->colors); if (status == MagickFalse) { tile_image=DestroyImage(tile_image); ThrowReaderException(ResourceLimitError, \"MemoryAllocationFailed\"); } if ((bytes_per_line & 0x8000) != 0) { for (i=0; i < (ssize_t) tile_image->colors; i++) { j=ReadBlobMSBShort(image) % tile_image->colors; if ((flags & 0x8000) != 0) j=(size_t) i; tile_image->colormap[j].red=(Quantum) ScaleShortToQuantum(ReadBlobMSBShort(image)); tile_image->colormap[j].green=(Quantum) ScaleShortToQuantum(ReadBlobMSBShort(image)); tile_image->colormap[j].blue=(Quantum) ScaleShortToQuantum(ReadBlobMSBShort(image)); } } else { for (i=0; i < (ssize_t) tile_image->colors; i++) { tile_image->colormap[i].red=(Quantum) (QuantumRange- tile_image->colormap[i].red); tile_image->colormap[i].green=(Quantum) (QuantumRange- tile_image->colormap[i].green); tile_image->colormap[i].blue=(Quantum) (QuantumRange- tile_image->colormap[i].blue); } } } if (ReadRectangle(image,&source) == MagickFalse) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); if (ReadRectangle(image,&destination) == MagickFalse) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); (void) ReadBlobMSBShort(image); if ((code == 0x91) || (code == 0x99) || (code == 0x9b)) { length=ReadBlobMSBShort(image); for (i=0; i < (ssize_t) (length-2); i++) (void) ReadBlobByte(image); } if ((code != 0x9a) && (code != 0x9b) && (bytes_per_line & 0x8000) == 0) pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1,&extent); else pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1U* pixmap.bits_per_pixel,&extent); if (pixels == (unsigned char *) NULL) { tile_image=DestroyImage(tile_image); ThrowReaderException(ResourceLimitError, \"MemoryAllocationFailed\"); } p=pixels; for (y=0; y < (ssize_t) tile_image->rows; y++) { if (p > (pixels+extent+image->columns)) ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\"); q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1, exception); if (q == (PixelPacket *) NULL) break; indexes=GetAuthenticIndexQueue(tile_image); for (x=0; x < (ssize_t) tile_image->columns; x++) { if (tile_image->storage_class == PseudoClass) { index=ConstrainColormapIndex(tile_image,*p); SetPixelIndex(indexes+x,index); SetPixelRed(q, tile_image->colormap[(ssize_t) index].red); SetPixelGreen(q, tile_image->colormap[(ssize_t) index].green); SetPixelBlue(q, tile_image->colormap[(ssize_t) index].blue); } else { if (pixmap.bits_per_pixel == 16) { i=(*p++); j=(*p); SetPixelRed(q,ScaleCharToQuantum( (unsigned char) ((i & 0x7c) << 1))); SetPixelGreen(q,ScaleCharToQuantum( (unsigned char) (((i & 0x03) << 6) | ((j & 0xe0) >> 2)))); SetPixelBlue(q,ScaleCharToQuantum( (unsigned char) ((j & 0x1f) << 3))); } else if (tile_image->matte == MagickFalse) { if (p > (pixels+extent+2*image->columns)) ThrowReaderException(CorruptImageError, \"NotEnoughPixelData\"); SetPixelRed(q,ScaleCharToQuantum(*p)); SetPixelGreen(q,ScaleCharToQuantum( *(p+tile_image->columns))); SetPixelBlue(q,ScaleCharToQuantum( *(p+2*tile_image->columns))); } else { if (p > (pixels+extent+3*image->columns)) ThrowReaderException(CorruptImageError, \"NotEnoughPixelData\"); SetPixelAlpha(q,ScaleCharToQuantum(*p)); SetPixelRed(q,ScaleCharToQuantum( *(p+tile_image->columns))); SetPixelGreen(q,ScaleCharToQuantum( *(p+2*tile_image->columns))); SetPixelBlue(q,ScaleCharToQuantum( *(p+3*tile_image->columns))); } } p++; q++; } if (SyncAuthenticPixels(tile_image,exception) == MagickFalse) break; if ((tile_image->storage_class == DirectClass) && (pixmap.bits_per_pixel != 16)) { p+=(pixmap.component_count-1)*tile_image->columns; if (p < pixels) break; } status=SetImageProgress(image,LoadImageTag,y,tile_image->rows); if (status == MagickFalse) break; } pixels=(unsigned char *) RelinquishMagickMemory(pixels); if (jpeg == MagickFalse) if ((code == 0x9a) || (code == 0x9b) || ((bytes_per_line & 0x8000) != 0)) (void) CompositeImage(image,CopyCompositeOp,tile_image, destination.left,destination.top); tile_image=DestroyImage(tile_image); break; } case 0xa1: { unsigned char *info; size_t type; type=ReadBlobMSBShort(image); length=ReadBlobMSBShort(image); if (length == 0) break; (void) ReadBlobMSBLong(image); length-=4; if (length == 0) break; info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info)); if (info == (unsigned char *) NULL) break; count=ReadBlob(image,length,info); (void) count; switch (type) { case 0xe0: { if (length == 0) break; profile=BlobToStringInfo((const void *) NULL,length); SetStringInfoDatum(profile,info); status=SetImageProfile(image,\"icc\",profile); profile=DestroyStringInfo(profile); if (status == MagickFalse) ThrowReaderException(ResourceLimitError, \"MemoryAllocationFailed\"); break; } case 0x1f2: { if (length == 0) break; profile=BlobToStringInfo((const void *) NULL,length); SetStringInfoDatum(profile,info); status=SetImageProfile(image,\"iptc\",profile); if (status == MagickFalse) ThrowReaderException(ResourceLimitError, \"MemoryAllocationFailed\"); profile=DestroyStringInfo(profile); break; } default: break; } info=(unsigned char *) RelinquishMagickMemory(info); break; } default: { if (code < 0) break; if (codes[code].length == -1) (void) ReadBlobMSBShort(image); else for (i=0; i < (ssize_t) codes[code].length; i++) (void) ReadBlobByte(image); } } } if (code == 0xc00) { for (i=0; i < 24; i++) (void) ReadBlobByte(image); continue; } if (((code >= 0xb0) && (code <= 0xcf)) || ((code >= 0x8000) && (code <= 0x80ff))) continue; if (code == 0x8200) { FILE *file; Image *tile_image; ImageInfo *read_info; int unique_file; jpeg=MagickTrue; read_info=CloneImageInfo(image_info); SetImageInfoBlob(read_info,(void *) NULL,0); file=(FILE *) NULL; unique_file=AcquireUniqueFileResource(read_info->filename); if (unique_file != -1) file=fdopen(unique_file,\"wb\"); if ((unique_file == -1) || (file == (FILE *) NULL)) { if (file != (FILE *) NULL) (void) fclose(file); (void) RelinquishUniqueFileResource(read_info->filename); (void) CopyMagickString(image->filename,read_info->filename, MaxTextExtent); ThrowFileException(exception,FileOpenError, \"UnableToCreateTemporaryFile\",image->filename); image=DestroyImageList(image); return((Image *) NULL); } length=ReadBlobMSBLong(image); for (i=0; i < 6; i++) (void) ReadBlobMSBLong(image); if (ReadRectangle(image,&frame) == MagickFalse) { (void) fclose(file); (void) RelinquishUniqueFileResource(read_info->filename); ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); } for (i=0; i < 122; i++) (void) ReadBlobByte(image); for (i=0; i < (ssize_t) (length-154); i++) { c=ReadBlobByte(image); (void) fputc(c,file); } (void) fclose(file); (void) close(unique_file); tile_image=ReadImage(read_info,exception); (void) RelinquishUniqueFileResource(read_info->filename); read_info=DestroyImageInfo(read_info); if (tile_image == (Image *) NULL) continue; (void) FormatLocaleString(geometry,MaxTextExtent,\"%.20gx%.20g\", (double) MagickMax(image->columns,tile_image->columns), (double) MagickMax(image->rows,tile_image->rows)); (void) SetImageExtent(image, MagickMax(image->columns,tile_image->columns), MagickMax(image->rows,tile_image->rows)); (void) TransformImageColorspace(image,tile_image->colorspace); (void) CompositeImage(image,CopyCompositeOp,tile_image,frame.left, frame.right); image->compression=tile_image->compression; tile_image=DestroyImage(tile_image); continue; } if ((code == 0xff) || (code == 0xffff)) break; if (((code >= 0xd0) && (code <= 0xfe)) || ((code >= 0x8100) && (code <= 0xffff))) { length=ReadBlobMSBShort(image); for (i=0; i < (ssize_t) length; i++) (void) ReadBlobByte(image); continue; } if ((code >= 0x100) && (code <= 0x7fff)) { length=(size_t) ((code >> 7) & 0xff); for (i=0; i < (ssize_t) length; i++) (void) ReadBlobByte(image); continue; } } (void) CloseBlob(image); return(GetFirstImageInList(image)); } ",
        "vulrepair": "<Vul_Start> if ((length!= (ssize_t) length) || (length < 4)) ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");<Vul_End>"
    },
    {
        "index": 183463,
        "output": "<Vul_Start> gfx::Rect view_rect(size_);<Vul_End>",
        "label": "<Vul_Start> gfx::Rect view_rect(size_);<Vul_End>",
        "match": true,
        "source": " void RenderWidget::didScrollRect(int dx, int dy, const WebRect& clip_rect) { bool update_pending = paint_aggregator_.HasPendingUpdate(); <Vul_Start> gfx::Rect view_rect(0, 0, size_.width(), size_.height()); <Vul_End> gfx::Rect damaged_rect = view_rect.Intersect(clip_rect); if (damaged_rect.IsEmpty()) return; paint_aggregator_.ScrollRect(dx, dy, damaged_rect); if (update_pending) return; if (!paint_aggregator_.HasPendingUpdate()) return; if (update_reply_pending()) return; MessageLoop::current()->PostTask(FROM_HERE, NewRunnableMethod( this, &RenderWidget::CallDoDeferredUpdate)); } ",
        "vulrepair": "<Vul_Start> const gfx::Rect& view_rect = gfx::Rect(size_);<Vul_End>"
    },
    {
        "index": 185269,
        "output": "<Vul_Start> void SerializerMarkupAccumulator::appendCustomAttributes(StringBuilder& out, Element* element, Namespaces* namespaces)<Vul_End><Vul_Start> appendAttribute(out, element, Attribute(frameOwnerURLAttributeName(*frameOwner), url.string()), namespaces);<Vul_End>",
        "label": "<Vul_Start> void SerializerMarkupAccumulator::appendCustomAttributes(StringBuilder& out, Element* element, Namespaces* namespaces)<Vul_End><Vul_Start> appendAttribute(out, element, Attribute(frameOwnerURLAttributeName(*frameOwner), url.string()), namespaces);<Vul_End>",
        "match": true,
        "source": " void SerializerMarkupAccumulator::appendCustomAttributes(StringBuilder& result, Element* element, Namespaces* namespaces) <Vul_Start><Vul_End> { if (!element->isFrameOwnerElement()) return; HTMLFrameOwnerElement* frameOwner = toHTMLFrameOwnerElement(element); Frame* frame = frameOwner->contentFrame(); if (!frame) return; KURL url = frame->document()->url(); if (url.isValid() && !url.isBlankURL()) return; url = m_serializer->urlForBlankFrame(frame); <Vul_Start> appendAttribute(result, element, Attribute(frameOwnerURLAttributeName(*frameOwner), url.string()), namespaces); <Vul_End> } ",
        "vulrepair": "<Vul_Start> void SerializerMarkupAccumulator::appendCustomAttributes(StringBuilder& result, Element* element, Namespaces* namespaces)<Vul_End><Vul_Start> appendAttribute(result, element, Attribute(frameOwnerURLAttributeName(*frameOwner), url.string()), namespaces);<Vul_End>"
    },
    {
        "index": 185999,
        "output": "<Vul_Start> const std::string& AppControllerService::MaybeGetAndroidPackageName(<Vul_End>",
        "label": "<Vul_Start> const std::string& AppControllerService::MaybeGetAndroidPackageName(<Vul_End>",
        "match": true,
        "source": " const std::string& AppControllerImpl::MaybeGetAndroidPackageName( <Vul_Start><Vul_End> const std::string& app_id) { const auto& package_name_it = android_package_map_.find(app_id); if (package_name_it != android_package_map_.end()) { return package_name_it->second; } ArcAppListPrefs* arc_prefs_ = ArcAppListPrefs::Get(profile_); if (!arc_prefs_) { return base::EmptyString(); } std::unique_ptr<ArcAppListPrefs::AppInfo> arc_info = arc_prefs_->GetApp(app_id); if (!arc_info) { return base::EmptyString(); } android_package_map_[app_id] = arc_info->package_name; return android_package_map_[app_id]; } ",
        "vulrepair": "<Vul_Start> const AppControllerService* AppControllerService::MaybeGetAndroidPackageName(<Vul_End>"
    },
    {
        "index": 183004,
        "output": "<Vul_Start> ND_PRINT((ndo, \"%s\", rpl_tstr));<Vul_End>",
        "label": "<Vul_Start> ND_PRINT((ndo, \"%s\", rpl_tstr));<Vul_End>",
        "match": true,
        "source": " rpl_print(netdissect_options *ndo, const struct icmp6_hdr *hdr, const u_char *bp, u_int length) { int secured = hdr->icmp6_code & 0x80; int basecode= hdr->icmp6_code & 0x7f; if(secured) { ND_PRINT((ndo, \", (SEC) [worktodo]\")); return; } else { ND_PRINT((ndo, \", (CLR)\")); } switch(basecode) { case ND_RPL_DAG_IS: ND_PRINT((ndo, \"DODAG Information Solicitation\")); if(ndo->ndo_vflag) { } break; case ND_RPL_DAG_IO: ND_PRINT((ndo, \"DODAG Information Object\")); if(ndo->ndo_vflag) { rpl_dio_print(ndo, bp, length); } break; case ND_RPL_DAO: ND_PRINT((ndo, \"Destination Advertisement Object\")); if(ndo->ndo_vflag) { rpl_dao_print(ndo, bp, length); } break; case ND_RPL_DAO_ACK: ND_PRINT((ndo, \"Destination Advertisement Object Ack\")); if(ndo->ndo_vflag) { rpl_daoack_print(ndo, bp, length); } break; default: ND_PRINT((ndo, \"RPL message, unknown code %u\",hdr->icmp6_code)); break; } return; #if 0 trunc: <Vul_Start> ND_PRINT((ndo,\" [|truncated]\")); <Vul_End> return; #endif } ",
        "vulrepair": "<Vul_Start> ND_PRINT((ndo, \" [|truncated]\"));<Vul_End>"
    },
    {
        "index": 184136,
        "output": "<Vul_Start> gtk_widget_hide(container_.get());<Vul_End>",
        "label": "<Vul_Start> gtk_widget_hide(container_.get());<Vul_End>",
        "match": true,
        "source": " void StatusBubbleGtk::Hide() { expand_timer_.Stop(); expand_animation_.reset(); <Vul_Start> gtk_widget_hide_all(container_.get()); <Vul_End> } ",
        "vulrepair": "<Vul_Start><Vul_End>"
    },
    {
        "index": 184971,
        "output": "<Vul_Start> if (ctxt->instate == XML_PARSER_EOF) { xmlFree (buf); return; }<Vul_End>",
        "label": "<Vul_Start> if (ctxt->instate == XML_PARSER_EOF) { xmlFree(buf); return; }<Vul_End>",
        "match": true,
        "source": " xmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf, int len, int size) { int q, ql; int r, rl; int cur, l; int count = 0; int inputid; inputid = ctxt->input->id; if (buf == NULL) { len = 0; size = XML_PARSER_BUFFER_SIZE; buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar)); if (buf == NULL) { xmlErrMemory(ctxt, NULL); return; } } GROW; q = CUR_CHAR(ql); if (q == 0) goto not_terminated; if (!IS_CHAR(q)) { xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR, \"xmlParseComment: invalid xmlChar value %d\\n\", q); xmlFree (buf); return; } NEXTL(ql); r = CUR_CHAR(rl); if (r == 0) goto not_terminated; if (!IS_CHAR(r)) { xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR, \"xmlParseComment: invalid xmlChar value %d\\n\", q); xmlFree (buf); return; } NEXTL(rl); cur = CUR_CHAR(l); if (cur == 0) goto not_terminated; while (IS_CHAR(cur) && ((cur != '>') || (r != '-') || (q != '-'))) { if ((r == '-') && (q == '-')) { xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL); } if (len + 5 >= size) { xmlChar *new_buf; size *= 2; new_buf = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar)); if (new_buf == NULL) { xmlFree (buf); xmlErrMemory(ctxt, NULL); return; } buf = new_buf; } COPY_BUF(ql,buf,len,q); q = r; ql = rl; r = cur; rl = l; count++; if (count > 50) { GROW; count = 0; <Vul_Start><Vul_End> } NEXTL(l); cur = CUR_CHAR(l); if (cur == 0) { SHRINK; GROW; cur = CUR_CHAR(l); } } buf[len] = 0; if (cur == 0) { xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED, \"Comment not terminated \\n<!--%.50s\\n\", buf); } else if (!IS_CHAR(cur)) { xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR, \"xmlParseComment: invalid xmlChar value %d\\n\", cur); } else { if (inputid != ctxt->input->id) { xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY, \"Comment doesn't start and stop in the same entity\\n\"); } NEXT; if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) && (!ctxt->disableSAX)) ctxt->sax->comment(ctxt->userData, buf); } xmlFree(buf); return; not_terminated: xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED, \"Comment not terminated\\n\", NULL); xmlFree(buf); return; } ",
        "vulrepair": "<Vul_Start> if (inputid == XML_PARSER_EOF) { xmlFree (buf); return; }<Vul_End>"
    },
    {
        "index": 184946,
        "output": "<Vul_Start> if (!context_)<Vul_End>",
        "label": "<Vul_Start> if (!context_)<Vul_End>",
        "match": true,
        "source": " void SocketStream::DoLoop(int result) { <Vul_Start> if (!context_.get()) <Vul_End> next_state_ = STATE_CLOSE; if (next_state_ == STATE_NONE) return; do { State state = next_state_; next_state_ = STATE_NONE; switch (state) { case STATE_BEFORE_CONNECT: DCHECK_EQ(OK, result); result = DoBeforeConnect(); break; case STATE_BEFORE_CONNECT_COMPLETE: result = DoBeforeConnectComplete(result); break; case STATE_RESOLVE_PROXY: DCHECK_EQ(OK, result); result = DoResolveProxy(); break; case STATE_RESOLVE_PROXY_COMPLETE: result = DoResolveProxyComplete(result); break; case STATE_RESOLVE_HOST: DCHECK_EQ(OK, result); result = DoResolveHost(); break; case STATE_RESOLVE_HOST_COMPLETE: result = DoResolveHostComplete(result); break; case STATE_RESOLVE_PROTOCOL: result = DoResolveProtocol(result); break; case STATE_RESOLVE_PROTOCOL_COMPLETE: result = DoResolveProtocolComplete(result); break; case STATE_TCP_CONNECT: result = DoTcpConnect(result); break; case STATE_TCP_CONNECT_COMPLETE: result = DoTcpConnectComplete(result); break; case STATE_GENERATE_PROXY_AUTH_TOKEN: result = DoGenerateProxyAuthToken(); break; case STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE: result = DoGenerateProxyAuthTokenComplete(result); break; case STATE_WRITE_TUNNEL_HEADERS: DCHECK_EQ(OK, result); result = DoWriteTunnelHeaders(); break; case STATE_WRITE_TUNNEL_HEADERS_COMPLETE: result = DoWriteTunnelHeadersComplete(result); break; case STATE_READ_TUNNEL_HEADERS: DCHECK_EQ(OK, result); result = DoReadTunnelHeaders(); break; case STATE_READ_TUNNEL_HEADERS_COMPLETE: result = DoReadTunnelHeadersComplete(result); break; case STATE_SOCKS_CONNECT: DCHECK_EQ(OK, result); result = DoSOCKSConnect(); break; case STATE_SOCKS_CONNECT_COMPLETE: result = DoSOCKSConnectComplete(result); break; case STATE_SECURE_PROXY_CONNECT: DCHECK_EQ(OK, result); result = DoSecureProxyConnect(); break; case STATE_SECURE_PROXY_CONNECT_COMPLETE: result = DoSecureProxyConnectComplete(result); break; case STATE_SECURE_PROXY_HANDLE_CERT_ERROR: result = DoSecureProxyHandleCertError(result); break; case STATE_SECURE_PROXY_HANDLE_CERT_ERROR_COMPLETE: result = DoSecureProxyHandleCertErrorComplete(result); break; case STATE_SSL_CONNECT: DCHECK_EQ(OK, result); result = DoSSLConnect(); break; case STATE_SSL_CONNECT_COMPLETE: result = DoSSLConnectComplete(result); break; case STATE_SSL_HANDLE_CERT_ERROR: result = DoSSLHandleCertError(result); break; case STATE_SSL_HANDLE_CERT_ERROR_COMPLETE: result = DoSSLHandleCertErrorComplete(result); break; case STATE_READ_WRITE: result = DoReadWrite(result); break; case STATE_AUTH_REQUIRED: Finish(result); return; case STATE_CLOSE: DCHECK_LE(result, OK); Finish(result); return; default: NOTREACHED() << \"bad state \" << state; Finish(result); return; } if (state == STATE_RESOLVE_PROTOCOL && result == ERR_PROTOCOL_SWITCHED) continue; if (state != STATE_READ_WRITE && result < ERR_IO_PENDING) { net_log_.EndEventWithNetErrorCode( NetLog::TYPE_SOCKET_STREAM_CONNECT, result); } } while (result != ERR_IO_PENDING); } ",
        "vulrepair": "<Vul_Start> if (!context_.get())<Vul_End>"
    },
    {
        "index": 179360,
        "output": "<Vul_Start> strncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));<Vul_End>",
        "label": "<Vul_Start> strncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));<Vul_End>",
        "match": true,
        "source": " static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) { struct xfrm_algo *algo; struct nlattr *nla; nla = nla_reserve(skb, XFRMA_ALG_AUTH, sizeof(*algo) + (auth->alg_key_len + 7) / 8); if (!nla) return -EMSGSIZE; algo = nla_data(nla); <Vul_Start> strcpy(algo->alg_name, auth->alg_name); <Vul_End> memcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8); algo->alg_key_len = auth->alg_key_len; return 0; } ",
        "vulrepair": "<Vul_Start> strcpy(algo->alg_name, auth->alg_name);<Vul_End>"
    },
    {
        "index": 187724,
        "output": "<Vul_Start> standard_test(png_store* const psIn, png_uint_32 const id,<Vul_End>",
        "label": "<Vul_Start> standard_test(png_store* const psIn, png_uint_32 const id,<Vul_End>",
        "match": true,
        "source": " standard_test(png_store* PNG_CONST psIn, png_uint_32 PNG_CONST id, <Vul_Start><Vul_End> int do_interlace, int use_update_info) { standard_display d; context(psIn, fault); standard_display_init(&d, psIn, id, do_interlace, use_update_info); Try { png_structp pp; png_infop pi; pp = set_store_for_read(d.ps, &pi, d.id, d.do_interlace ? (d.ps->progressive ? \"pngvalid progressive deinterlacer\" : \"pngvalid sequential deinterlacer\") : (d.ps->progressive ? \"progressive reader\" : \"sequential reader\")); standard_palette_init(&d); if (d.ps->progressive) { png_set_progressive_read_fn(pp, &d, standard_info, progressive_row, standard_end); store_progressive_read(d.ps, pp, pi); } else { png_set_read_fn(pp, d.ps, store_read); png_read_info(pp, pi); standard_info_imp(&d, pp, pi, 2 ); { sequential_row(&d, pp, pi, 0, 1); if (!d.speed) { standard_text_validate(&d, pp, pi, 1); standard_image_validate(&d, pp, 0, 1); } else d.ps->validated = 1; } } if (!d.ps->validated) png_error(pp, \"image read failed silently\"); } Catch(fault) d.ps = fault; store_read_reset(d.ps); } ",
        "vulrepair": "<Vul_Start> void standard_test(png_store* const psIn, png_uint_32 const id,<Vul_End>"
    },
    {
        "index": 180732,
        "output": "<Vul_Start> int i;<Vul_End><Vul_Start> for (i = 0; i < 3; i++)<Vul_End><Vul_Start> kvm_pit_load_count(kvm, i, ps->channels[i].count, 0);<Vul_End>",
        "label": "<Vul_Start> int i;<Vul_End><Vul_Start> for (i = 0; i < 3; i++)<Vul_End><Vul_Start> kvm_pit_load_count(kvm, i, ps->channels[i].count, 0);<Vul_End>",
        "match": true,
        "source": " static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps) { <Vul_Start><Vul_End> mutex_lock(&kvm->arch.vpit->pit_state.lock); memcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state)); <Vul_Start><Vul_End> <Vul_Start> kvm_pit_load_count(kvm, 0, ps->channels[0].count, 0); <Vul_End> mutex_unlock(&kvm->arch.vpit->pit_state.lock); return 0; } ",
        "vulrepair": "<Vul_Start> int ret;<Vul_End><Vul_Start> ret = kvm_pit_load_count(kvm, 0, ps->channels[0].count, 0); if (ret < 0) return ret;<Vul_End><Vul_Start> ret = kvm_pit_commit(kvm, 0, 0); if (ret < 0) return ret;<Vul_End>"
    },
    {
        "index": 182735,
        "output": "<Vul_Start> blob_info->data=NULL;<Vul_End>",
        "label": "<Vul_Start> blob_info->data=NULL;<Vul_End>",
        "match": true,
        "source": " MagickExport unsigned char *DetachBlob(BlobInfo *blob_info) { unsigned char *data; assert(blob_info != (BlobInfo *) NULL); if (blob_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\"); if (blob_info->mapped != MagickFalse) { (void) UnmapBlob(blob_info->data,blob_info->length); <Vul_Start><Vul_End> RelinquishMagickResource(MapResource,blob_info->length); } blob_info->mapped=MagickFalse; blob_info->length=0; blob_info->offset=0; blob_info->eof=MagickFalse; blob_info->error=0; blob_info->exempt=MagickFalse; blob_info->type=UndefinedStream; blob_info->file_info.file=(FILE *) NULL; data=blob_info->data; blob_info->data=(unsigned char *) NULL; blob_info->stream=(StreamHandler) NULL; return(data); } ",
        "vulrepair": "<Vul_Start> blob_info->data=(unsigned char *) NULL;<Vul_End>"
    }
]